https://www.elastic.co/blog/ten-process-injection-techniques-technical-survey-common-and-trending-process
# Ten process injection techniques:

## 1. CLASSIC DLL INJECTION VIA CREATE REMOTE THREAD AND LOAD LIBRARY

1- The malware first needs to target a process for injection (e.g. svchost.exe) by searching through processes by calling a trio of Application Program Interfaces (APIs): CreateToolhelp32Snapshot, Process32First, and Process32Next
2- the malware calls VirtualAllocEx to have a space to write the path to its DLL.
3- The malware then calls WriteProcessMemory to write the path in the allocated memory.
4- the malware calls APIs such as CreateRemoteThread, NtCreateThreadEx, or RtlCreateUserThread.

## 2. PORTABLE EXECUTABLE INJECTION (PE INJECTION)

1- The malware first needs to target a process for injection (e.g. svchost.exe) by searching through processes by calling a trio of Application Program Interfaces (APIs): CreateToolhelp32Snapshot, Process32First, and Process32Next
2- the malware calls VirtualAllocEx to have a space to write malicious code.
3- The malware then calls WriteProcessMemory to write the malicious code in the allocated memory.
4- the malware calls APIs such as CreateRemoteThread, NtCreateThreadEx, or RtlCreateUserThread.

When a malware injects its PE into another process it will have a new base address which is unpredictable, requiring it to dynamically recompute the fixed addresses of its PE. To overcome this, the malware needs to find its relocation table address in the host process, and resolve the absolute addresses of the copied image by looping through its relocation descriptors.

memory module and reflective DLL injection approaches are even stealthier becuase They do not rely on any extra Windows APIs (e.g., CreateRemoteThread or LoadLibrary)

Reflective DLL injection works by creating a DLL that maps itself into memory when executed, instead of relying on the Window’s loader.

Memory Module is similar to Reflective DLL injection except the injector or loader is responsible for mapping the target DLL into memory instead of the DLL mapping itself.

When analyzing PE injection, it is very common to see loops (usually two “for” loops, one nested in the other), before a call to CreateRemoteThread.

The “and 0x0fff” instruction is also another good indicator, showing that the first 12 bits are used to get the offset into the virtual address of the containing relocation block. Now that the malware has recomputed all the necessary addresses, all it needs to do is pass its starting address to CreateRemoteThread and have it executed.


## 3. PROCESS HOLLOWING (A.K.A PROCESS REPLACEMENT AND RUNPE)

Process hollowing occurs when a malware unmaps (hollows out) the legitimate code from memory of the target process, and overwrites the memory space of the target process (e.g., svchost.exe) with a malicious executable.

1- The malware first creates a new process to host the malicious code in suspended mode by calling CreateProcess and setting the Process Creation Flag to CREATE_SUSPENDED (0x00000004).

he primary thread of the new process is created in a suspended state, and does not run until the ResumeThread function is called.

2- the malware needs to swap out the contents of the legitimate file with its malicious payload. This is done by unmapping the memory of the target process by calling either ZwUnmapViewOfSection or NtUnmapViewOfSection.

3- the loader performs VirtualAllocEx to allocate new memory for the malware, and uses WriteProcessMemory to write each of the malware’s sections to the target process space.

4- The malware calls SetThreadContext to point the entrypoint to a new code section that it has written. 

5- the malware resumes the suspended thread by calling ResumeThread to take the process out of suspended state.

## 4. THREAD EXECUTION HIJACKING (A.K.A SUSPEND, INJECT, AND RESUME (SIR))

In thread execution hijacking, malware targets an existing thread of a process and avoids any noisy process or thread creations operations.

1- the malware gets a handle to the target thread by using CreateToolhelp32Snapshot and Thread32First followed by OpenThread.

2- the malware puts the thread into suspended mode by calling SuspendThread to perform its injection.

3- the malware modifies the EIP register of the targeted thread by calling SetThreadContext.

4- The malware calls VirtualAllocEx and WriteProcessMemory to allocate memory and perform the code injection (The code can contain shellcode, the path to the malicious DLL, and the address of LoadLibrary).

From the attacker’s perspective, the SIR approach can be problematic because suspending and resuming a thread in the middle of a system call can cause the system to crash. To avoid this, a more sophisticated malware would resume and retry later if the EIP register is within the range of NTDLL.dll.


## 5. HOOK INJECTION VIA "SetWindowsHookEx"

Hooking is a technique used to intercept function calls. Malware can leverage hooking functionality to have their malicious DLL loaded upon an event getting triggered in a specific thread.

The SetWindowsHookEx function takes four arguments : 
1- The first argument is the type of event. The events reflect the [range of hook types](https://msdn.microsoft.com/en-us/library/windows/desktop/ms644959\(v=vs.85\).aspx), and vary from pressing keys on the keyboard (WH_KEYBOARD) to inputs to the mouse (WH_MOUSE), CBT, etc. 
2- The second argument is a pointer to the function the malware wants to invoke upon the event execution.
3- The third argument is a module that contains the function. 
Thus, it is very common to see calls to LoadLibrary and GetProcAddress before calling SetWindowsHookEx. 
4- The last argument to this function is the thread with which the hook procedure is to be associated. If this value is set to zero all threads perform the action when the event is triggered. 

However, malware usually targets one thread for less noise, thus it is also possible to see calls CreateToolhelp32Snapshot and Thread32Next before SetWindowsHookEx to find and target a single thread. Once the DLL is injected, the malware executes its malicious code on behalf of the process that its threadId was passed to SetWindowsHookEx function. 



## 6. INJECTION AND PERSISTENCE VIA REGISTRY MODIFICATION (E.G. APPINIT_DLLS, APPCERTDLLS, IFEO)


Appinit_DLL, AppCertDlls, and IFEO (Image File Execution Options) are all registry keys that malware uses for both injection and persistence. The entries are located at the following locations:

`HKLM\Software\Microsoft\Windows NT\CurrentVersion\Windows\Appinit_Dlls` 
`HKLM\Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows\Appinit_Dlls` 
`HKLM\System\CurrentControlSet\Control\Session Manager\AppCertDlls` 
`HKLM\Software\Microsoft\Windows NT\currentversion\image file execution options`

### AppInit_DLLs

Malware can insert the location of their malicious library under the Appinit_Dlls registry key to have another process load their library. Every library under this registry key is loaded into every process that loads User32.dll. User32.dll is a very common library used for storing graphical elements such as dialog boxes. Thus, when a malware modifies this subkey, the majority of processes will load the malicious library.

 It simply opens the Appinit_Dlls registry key by calling RegCreateKeyEx, and modifies its values by calling RegSetValueEx.


### AppCertDlls

This approach is very similar to the AppInit_DLLs approach, except that DLLs under this registry key are loaded into every process that calls the Win32 API functions CreateProcess, CreateProcessAsUser, CreateProcessWithLogonW, CreateProcessWithTokenW, and WinExec.


### Image File Execution Options (IFEO)

IFEO is typically used for debugging purposes. Developers can set the “Debugger Value” under this registry key to attach a program to another executable for debugging. Therefore, whenever the executable is launched the program that is attached to it will be launched. To use this feature you can simply give the path to the debugger, and attach it to the executable that you want to analyze. Malware can modify this registry key to inject itself into the target executable.



## 7. APC INJECTION AND ATOM BOMBING

Malware can take advantage of [Asynchronous Procedure Calls (APC)](https://msdn.microsoft.com/en-us/library/windows/desktop/ms681951\(v=vs.85\).aspx) to force another thread to execute their custom code by attaching it to the APC Queue of the target thread.

Each thread has a queue of APCs which are waiting for execution upon the target thread entering alterable state. 
A thread enters an alertable state if it calls SleepEx, SignalObjectAndWait, MsgWaitForMultipleObjectsEx, WaitForMultipleObjectsEx, or WaitForSingleObjectEx functions

The malware usually looks for any thread that is in an alterable state, and then calls OpenThread and QueueUserAPC to queue an APC to a thread.

QueueUserAPC takes three arguments: 
1) a handle to the target thread; 
2) a pointer to the function that the malware wants to run; 
3) and the parameter that is passed to the function pointer.


## 8. EXTRA WINDOW MEMORY INJECTION (EWMI) VIA "SetWindowLong"

When registering a window class, an application can specify a number of additional bytes of memory, called extra window memory (EWM). However, there is not much room in EWM. To circumvent this limitation, the malware writes code into a shared section of explorer.exe, and uses SetWindowLong and SendNotifyMessage to have a function pointer to point to the shellcode, and then execute it.

The malware has two options when it comes to writing into a shared section. 
1) It can either create a shared section and have it mapped both to itself and to another process (e.g., explorer.exe).
2) or it can simply open a shared section that already exists.

After malware writes its shellcode in a shared section, it uses GetWindowLong and SetWindowLong to access and modify the extra window memory of “Shell_TrayWnd”.

GetWindowLong is an API used to retrieve the 32-bit value at the specified offset into the extra window memory of a window class object, and SetWindowLong is used to change values at the specified offset.

By doing this, the malware can simply change the offset of a function pointer in the window class, and point it to the shellcode written to the shared section.

Like most other techniques mentioned above, the malware needs to trigger the code that it has written. In previously discussed techniques, malware achieved this by calling APIs such as CreateRemoteThread, QueueUserAPC, or SetThreadContext. With this approach, the malware instead triggers the injected code by calling SendNotifyMessage. Upon execution of SendNotifyMessage, Shell_TrayWnd receives and transfers control to the address pointed to by the value previously set by SetWindowLong.


## 9. INJECTION USING SHIMS

Shims allow developers to apply fixes to their programs without the need of rewriting code.
By leveraging shims, developers can tell the operating system how to handle their application. 
Shims are essentially a way of hooking into APIs and targeting specific executables. 
Malware can take advantage of shims to target an executable for both persistence and injection. 
Windows runs the Shim Engine when it loads a binary to check for shimming databases in order to apply the appropriate fixes.


## 10. IAT HOOKING AND INLINE HOOKING (A.K.A USERLAND ROOTKITS)

IAT hooking is a technique that malware uses to change the import address table by modifying where the CreateWindowEx points.

with inline hooking, malware modifies the API function itself.



---
---
---

# **DLL (Dynamic Link Library) in Windows**

A **Dynamic Link Library (DLL)** is a shared library file format in Windows that contains code and data used by multiple programs simultaneously. DLLs help modularize applications, reduce memory usage, and improve system efficiency by allowing programs to share common functionality.

---

## **Types of DLLs in Windows**
DLLs can be categorized based on their usage and linking methods:

### **1. Based on Linking Method**
- **Statically Linked DLLs**  
  - Loaded at program startup.  
  - Functions are resolved at compile time.  
  - Example: Standard system libraries like `kernel32.dll`.  

- **Dynamically Linked DLLs**  
  - Loaded at runtime using `LoadLibrary()` or `LoadLibraryEx()`.  
  - Functions are resolved at runtime using `GetProcAddress()`.  
  - Example: Plugins or extensions loaded on demand.  

### **2. Based on Usage**
- **System DLLs**  
  - Provided by Microsoft as part of Windows.  
  - Example: `user32.dll` (GUI functions), `advapi32.dll` (registry & security).  

- **Application-Specific DLLs**  
  - Created by developers for a specific application.  
  - Example: A game might use `physics_engine.dll`.  

- **Third-Party DLLs**  
  - Developed by external vendors.  
  - Example: `nvidia.dll` (GPU drivers), `vcruntime140.dll` (Visual C++ Redistributable).  

---

## **Functions of DLLs in Windows**
DLLs provide reusable functionality, including:
- **Core OS Operations** (`ntdll.dll`, `kernel32.dll`)  
- **GUI & Window Management** (`user32.dll`, `gdi32.dll`)  
- **Networking** (`ws2_32.dll`, `wininet.dll`)  
- **Security & Authentication** (`advapi32.dll`, `crypt32.dll`)  
- **Multimedia & DirectX** (`d3d11.dll`, `winmm.dll`)  
- **Database Access** (`odbc32.dll`, `sqlite3.dll`)  

---

## **Best Tools to Monitor DLLs in Windows**
Monitoring DLLs helps in debugging, malware analysis, and performance optimization.

### **1. Process Explorer (Sysinternals)**  
- Displays loaded DLLs for each process.  
- Highlights suspicious or unsigned DLLs.  
- Download: [https://learn.microsoft.com/en-us/sysinternals/downloads/process-explorer](https://learn.microsoft.com/en-us/sysinternals/downloads/process-explorer)  

### **2. Dependency Walker (Depends.exe)**  
- Analyzes DLL dependencies.  
- Detects missing or broken DLLs.  
- Download: [http://www.dependencywalker.com/](http://www.dependencywalker.com/)  

### **3. Process Monitor (ProcMon, Sysinternals)**  
- Logs DLL loads/unloads in real-time.  
- Tracks file and registry access by DLLs.  
- Download: [https://learn.microsoft.com/en-us/sysinternals/downloads/procmon](https://learn.microsoft.com/en-us/sysinternals/downloads/procmon)  

### **4. Autoruns (Sysinternals)**  
- Detects DLLs loaded at startup (via registry, services, etc.).  
- Useful for finding malicious DLL injections.  
- Download: [https://learn.microsoft.com/en-us/sysinternals/downloads/autoruns](https://learn.microsoft.com/en-us/sysinternals/downloads/autoruns)  

### **5. API Monitor**  
- Intercepts API calls made by DLLs.  
- Useful for reverse engineering.  
- Download: [http://www.rohitab.com/apimonitor](http://www.rohitab.com/apimonitor)  

### **6. DLL Export Viewer (NirSoft)**  
- Lists exported functions from a DLL.  
- Helps in analyzing third-party DLLs.  
- Download: [https://www.nirsoft.net/utils/dll_export_viewer.html](https://www.nirsoft.net/utils/dll_export_viewer.html)  

---

## **Conclusion**
DLLs are essential for Windows applications, providing modularity and code reuse. Monitoring them helps in debugging, security analysis, and performance tuning. Tools like **Process Explorer, Dependency Walker, and Process Monitor** are highly recommended for analyzing DLL behavior in Windows.  

Would you like details on a specific aspect of DLLs?

































































