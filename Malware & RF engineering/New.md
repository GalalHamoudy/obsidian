https://www.elastic.co/blog/ten-process-injection-techniques-technical-survey-common-and-trending-process
# Ten process injection techniques:

## 1. CLASSIC DLL INJECTION VIA CREATE REMOTE THREAD AND LOAD LIBRARY

1- The malware first needs to target a process for injection (e.g. svchost.exe) by searching through processes by calling a trio of Application Program Interfaces (APIs): CreateToolhelp32Snapshot, Process32First, and Process32Next
2- the malware calls VirtualAllocEx to have a space to write the path to its DLL.
3- The malware then calls WriteProcessMemory to write the path in the allocated memory.
4- the malware calls APIs such as CreateRemoteThread, NtCreateThreadEx, or RtlCreateUserThread.

## 2. PORTABLE EXECUTABLE INJECTION (PE INJECTION)

1- The malware first needs to target a process for injection (e.g. svchost.exe) by searching through processes by calling a trio of Application Program Interfaces (APIs): CreateToolhelp32Snapshot, Process32First, and Process32Next
2- the malware calls VirtualAllocEx to have a space to write malicious code.
3- The malware then calls WriteProcessMemory to write the malicious code in the allocated memory.
4- the malware calls APIs such as CreateRemoteThread, NtCreateThreadEx, or RtlCreateUserThread.

When a malware injects its PE into another process it will have a new base address which is unpredictable, requiring it to dynamically recompute the fixed addresses of its PE. To overcome this, the malware needs to find its relocation table address in the host process, and resolve the absolute addresses of the copied image by looping through its relocation descriptors.

memory module and reflective DLL injection approaches are even stealthier becuase They do not rely on any extra Windows APIs (e.g., CreateRemoteThread or LoadLibrary)

Reflective DLL injection works by creating a DLL that maps itself into memory when executed, instead of relying on the Window’s loader.

Memory Module is similar to Reflective DLL injection except the injector or loader is responsible for mapping the target DLL into memory instead of the DLL mapping itself.

When analyzing PE injection, it is very common to see loops (usually two “for” loops, one nested in the other), before a call to CreateRemoteThread.

The “and 0x0fff” instruction is also another good indicator, showing that the first 12 bits are used to get the offset into the virtual address of the containing relocation block. Now that the malware has recomputed all the necessary addresses, all it needs to do is pass its starting address to CreateRemoteThread and have it executed.


## 3. PROCESS HOLLOWING (A.K.A PROCESS REPLACEMENT AND RUNPE)

Process hollowing occurs when a malware unmaps (hollows out) the legitimate code from memory of the target process, and overwrites the memory space of the target process (e.g., svchost.exe) with a malicious executable.

1- The malware first creates a new process to host the malicious code in suspended mode by calling CreateProcess and setting the Process Creation Flag to CREATE_SUSPENDED (0x00000004).

he primary thread of the new process is created in a suspended state, and does not run until the ResumeThread function is called.

2- the malware needs to swap out the contents of the legitimate file with its malicious payload. This is done by unmapping the memory of the target process by calling either ZwUnmapViewOfSection or NtUnmapViewOfSection.

3- the loader performs VirtualAllocEx to allocate new memory for the malware, and uses WriteProcessMemory to write each of the malware’s sections to the target process space.

4- The malware calls SetThreadContext to point the entrypoint to a new code section that it has written. 

5- the malware resumes the suspended thread by calling ResumeThread to take the process out of suspended state.

## 4. THREAD EXECUTION HIJACKING (A.K.A SUSPEND, INJECT, AND RESUME (SIR))

In thread execution hijacking, malware targets an existing thread of a process and avoids any noisy process or thread creations operations.

1- the malware gets a handle to the target thread by using CreateToolhelp32Snapshot and Thread32First followed by OpenThread.

2- the malware puts the thread into suspended mode by calling SuspendThread to perform its injection.

3- the malware modifies the EIP register of the targeted thread by calling SetThreadContext.

4- The malware calls VirtualAllocEx and WriteProcessMemory to allocate memory and perform the code injection (The code can contain shellcode, the path to the malicious DLL, and the address of LoadLibrary).

From the attacker’s perspective, the SIR approach can be problematic because suspending and resuming a thread in the middle of a system call can cause the system to crash. To avoid this, a more sophisticated malware would resume and retry later if the EIP register is within the range of NTDLL.dll.


## 5. HOOK INJECTION VIA "SetWindowsHookEx"

Hooking is a technique used to intercept function calls. Malware can leverage hooking functionality to have their malicious DLL loaded upon an event getting triggered in a specific thread.

The SetWindowsHookEx function takes four arguments : 
1- The first argument is the type of event. The events reflect the [range of hook types](https://msdn.microsoft.com/en-us/library/windows/desktop/ms644959\(v=vs.85\).aspx), and vary from pressing keys on the keyboard (WH_KEYBOARD) to inputs to the mouse (WH_MOUSE), CBT, etc. 
2- The second argument is a pointer to the function the malware wants to invoke upon the event execution.
3- The third argument is a module that contains the function. 
Thus, it is very common to see calls to LoadLibrary and GetProcAddress before calling SetWindowsHookEx. 
4- The last argument to this function is the thread with which the hook procedure is to be associated. If this value is set to zero all threads perform the action when the event is triggered. 

However, malware usually targets one thread for less noise, thus it is also possible to see calls CreateToolhelp32Snapshot and Thread32Next before SetWindowsHookEx to find and target a single thread. Once the DLL is injected, the malware executes its malicious code on behalf of the process that its threadId was passed to SetWindowsHookEx function. 



## 6. INJECTION AND PERSISTENCE VIA REGISTRY MODIFICATION (E.G. APPINIT_DLLS, APPCERTDLLS, IFEO)


Appinit_DLL, AppCertDlls, and IFEO (Image File Execution Options) are all registry keys that malware uses for both injection and persistence. The entries are located at the following locations:

`HKLM\Software\Microsoft\Windows NT\CurrentVersion\Windows\Appinit_Dlls` 
`HKLM\Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows\Appinit_Dlls` 
`HKLM\System\CurrentControlSet\Control\Session Manager\AppCertDlls` 
`HKLM\Software\Microsoft\Windows NT\currentversion\image file execution options`

### AppInit_DLLs

Malware can insert the location of their malicious library under the Appinit_Dlls registry key to have another process load their library. Every library under this registry key is loaded into every process that loads User32.dll. User32.dll is a very common library used for storing graphical elements such as dialog boxes. Thus, when a malware modifies this subkey, the majority of processes will load the malicious library.

 It simply opens the Appinit_Dlls registry key by calling RegCreateKeyEx, and modifies its values by calling RegSetValueEx.


### AppCertDlls

This approach is very similar to the AppInit_DLLs approach, except that DLLs under this registry key are loaded into every process that calls the Win32 API functions CreateProcess, CreateProcessAsUser, CreateProcessWithLogonW, CreateProcessWithTokenW, and WinExec.


### Image File Execution Options (IFEO)

IFEO is typically used for debugging purposes. Developers can set the “Debugger Value” under this registry key to attach a program to another executable for debugging. Therefore, whenever the executable is launched the program that is attached to it will be launched. To use this feature you can simply give the path to the debugger, and attach it to the executable that you want to analyze. Malware can modify this registry key to inject itself into the target executable.



## 7. APC INJECTION AND ATOM BOMBING

Malware can take advantage of [Asynchronous Procedure Calls (APC)](https://msdn.microsoft.com/en-us/library/windows/desktop/ms681951\(v=vs.85\).aspx) to force another thread to execute their custom code by attaching it to the APC Queue of the target thread.

Each thread has a queue of APCs which are waiting for execution upon the target thread entering alterable state. 
A thread enters an alertable state if it calls SleepEx, SignalObjectAndWait, MsgWaitForMultipleObjectsEx, WaitForMultipleObjectsEx, or WaitForSingleObjectEx functions

The malware usually looks for any thread that is in an alterable state, and then calls OpenThread and QueueUserAPC to queue an APC to a thread.

QueueUserAPC takes three arguments: 
1) a handle to the target thread; 
2) a pointer to the function that the malware wants to run; 
3) and the parameter that is passed to the function pointer.


## 8. EXTRA WINDOW MEMORY INJECTION (EWMI) VIA "SetWindowLong"

When registering a window class, an application can specify a number of additional bytes of memory, called extra window memory (EWM). However, there is not much room in EWM. To circumvent this limitation, the malware writes code into a shared section of explorer.exe, and uses SetWindowLong and SendNotifyMessage to have a function pointer to point to the shellcode, and then execute it.

The malware has two options when it comes to writing into a shared section. 
1) It can either create a shared section and have it mapped both to itself and to another process (e.g., explorer.exe).
2) or it can simply open a shared section that already exists.

After malware writes its shellcode in a shared section, it uses GetWindowLong and SetWindowLong to access and modify the extra window memory of “Shell_TrayWnd”.

GetWindowLong is an API used to retrieve the 32-bit value at the specified offset into the extra window memory of a window class object, and SetWindowLong is used to change values at the specified offset.

By doing this, the malware can simply change the offset of a function pointer in the window class, and point it to the shellcode written to the shared section.

Like most other techniques mentioned above, the malware needs to trigger the code that it has written. In previously discussed techniques, malware achieved this by calling APIs such as CreateRemoteThread, QueueUserAPC, or SetThreadContext. With this approach, the malware instead triggers the injected code by calling SendNotifyMessage. Upon execution of SendNotifyMessage, Shell_TrayWnd receives and transfers control to the address pointed to by the value previously set by SetWindowLong.


## 9. INJECTION USING SHIMS

Shims allow developers to apply fixes to their programs without the need of rewriting code.
By leveraging shims, developers can tell the operating system how to handle their application. 
Shims are essentially a way of hooking into APIs and targeting specific executables. 
Malware can take advantage of shims to target an executable for both persistence and injection. 
Windows runs the Shim Engine when it loads a binary to check for shimming databases in order to apply the appropriate fixes.


## 10. IAT HOOKING AND INLINE HOOKING (A.K.A USERLAND ROOTKITS)

IAT hooking is a technique that malware uses to change the import address table by modifying where the CreateWindowEx points.

with inline hooking, malware modifies the API function itself.



---
---
---

# **DLL (Dynamic Link Library) in Windows**

A **Dynamic Link Library (DLL)** is a shared library file format in Windows that contains code and data used by multiple programs simultaneously. DLLs help modularize applications, reduce memory usage, and improve system efficiency by allowing programs to share common functionality.

---

## **Types of DLLs in Windows**
DLLs can be categorized based on their usage and linking methods:

### **1. Based on Linking Method**
- **Statically Linked DLLs**  
  - Loaded at program startup.  
  - Functions are resolved at compile time.  
  - Example: Standard system libraries like `kernel32.dll`.  

- **Dynamically Linked DLLs**  
  - Loaded at runtime using `LoadLibrary()` or `LoadLibraryEx()`.  
  - Functions are resolved at runtime using `GetProcAddress()`.  
  - Example: Plugins or extensions loaded on demand.  

### **2. Based on Usage**
- **System DLLs**  
  - Provided by Microsoft as part of Windows.  
  - Example: `user32.dll` (GUI functions), `advapi32.dll` (registry & security).  

- **Application-Specific DLLs**  
  - Created by developers for a specific application.  
  - Example: A game might use `physics_engine.dll`.  

- **Third-Party DLLs**  
  - Developed by external vendors.  
  - Example: `nvidia.dll` (GPU drivers), `vcruntime140.dll` (Visual C++ Redistributable).  

---

## **Functions of DLLs in Windows**
DLLs provide reusable functionality, including:
- **Core OS Operations** (`ntdll.dll`, `kernel32.dll`)  
- **GUI & Window Management** (`user32.dll`, `gdi32.dll`)  
- **Networking** (`ws2_32.dll`, `wininet.dll`)  
- **Security & Authentication** (`advapi32.dll`, `crypt32.dll`)  
- **Multimedia & DirectX** (`d3d11.dll`, `winmm.dll`)  
- **Database Access** (`odbc32.dll`, `sqlite3.dll`)  

---

## **Best Tools to Monitor DLLs in Windows**
Monitoring DLLs helps in debugging, malware analysis, and performance optimization.

### **1. Process Explorer (Sysinternals)**  
- Displays loaded DLLs for each process.  
- Highlights suspicious or unsigned DLLs.  
- Download: [https://learn.microsoft.com/en-us/sysinternals/downloads/process-explorer](https://learn.microsoft.com/en-us/sysinternals/downloads/process-explorer)  

### **2. Dependency Walker (Depends.exe)**  
- Analyzes DLL dependencies.  
- Detects missing or broken DLLs.  
- Download: [http://www.dependencywalker.com/](http://www.dependencywalker.com/)  

### **3. Process Monitor (ProcMon, Sysinternals)**  
- Logs DLL loads/unloads in real-time.  
- Tracks file and registry access by DLLs.  
- Download: [https://learn.microsoft.com/en-us/sysinternals/downloads/procmon](https://learn.microsoft.com/en-us/sysinternals/downloads/procmon)  

### **4. Autoruns (Sysinternals)**  
- Detects DLLs loaded at startup (via registry, services, etc.).  
- Useful for finding malicious DLL injections.  
- Download: [https://learn.microsoft.com/en-us/sysinternals/downloads/autoruns](https://learn.microsoft.com/en-us/sysinternals/downloads/autoruns)  

### **5. API Monitor**  
- Intercepts API calls made by DLLs.  
- Useful for reverse engineering.  
- Download: [http://www.rohitab.com/apimonitor](http://www.rohitab.com/apimonitor)  

### **6. DLL Export Viewer (NirSoft)**  
- Lists exported functions from a DLL.  
- Helps in analyzing third-party DLLs.  
- Download: [https://www.nirsoft.net/utils/dll_export_viewer.html](https://www.nirsoft.net/utils/dll_export_viewer.html)  

---

## **Conclusion**
DLLs are essential for Windows applications, providing modularity and code reuse. Monitoring them helps in debugging, security analysis, and performance tuning. Tools like **Process Explorer, Dependency Walker, and Process Monitor** are highly recommended for analyzing DLL behavior in Windows.  

---
---

# x86 Architecture Overview

### The Instruction Pointer:
**The Instruction Pointer** is a register that contains the address of the next instruction to be executed by the CPU. It is also called the Program Counter. It was originally a 16-bit register in the Intel 8086 processor (from where the term x86 originated) and was abbreviated as IP. In 32-bit processors, the Instruction Pointer became a 32-bit register called the EIP or the Extended Instruction Pointer. In 64-bit systems, this register became a 64-bit register called RIP (the R here stands for register).


### R8-R15:

These **64-bit general-purpose registers** are not present in ~~32-bit systems~~. They were introduced in the 64-bit systems. They are also addressable in 32-bit, 16-bit, and 8-bit modes. For example, for the R8 register, we can use R8D for lower 32-bit addressing, R8W for lower 16-bit addressing, and R8B for lower 8-bit addressing. Here, the suffix D stands for Double-word, W stands for Word, and B stands for Byte.

## Status Flag Registers:

When performing execution, some indication about the status of the execution is sometimes required. This is where the Status Flags come in. This is a single 32-bit register for 32-bit systems called EFLAGS, which is extended to 64-bits for 64-bit systems, and called RFLAGS in the 64-bit system. The status flags register consists of individual single-bit flags that can be either 1 or 0.

## Segment Registers:

Segment Registers are 16-bit registers that convert the flat memory space into different segments for easier addressing. There are six segment registers, as explained below:

**Code Segment:** The Code Segment (CS ) register points to the Code section in the memory.
**Data Segment:** The Data Segment (DS) register points to the program's data section in the memory.
**Stack Segment:** The Stack Segment (SS) register points to the program's Stack in the memory.
**Extra Segments (ES, FS, and GS):** These extra segment registers point to different data sections. These and the DS register divide the program's memory into four distinct data sections


Memory is divided into different sections, namely Stack, Heap, Code, and Data.

---
# x86 Assembly Crash Course

`040000:    b8 5f 00 00 00    mov eax, 0x5f`

Here, the `040000:` corresponds to the address where the instruction is located. `b8` refers to the opcode of the instruction `mov eax`, and `5F 00 00 00` indicates the other operand `0x5f`. Please note that due to [endianness](https://en.wikipedia.org/wiki/Endianness), the operand 0x5f is written as `5f 00 00 00`, which is actually `00 00 00 5f` but in little-endian notation.

**pusha (push all words):** Pushes all the 16-bit general purpose registers to the stack, i.e. AX, BX, CX, DX, SI, DI, SP, BP  
**pushad (push all double words):** Pushes all the 32-bit general purpose registers to the stack, i.e. EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP

---
# Windows Internals

The theoretical maximum virtual address space is 4 GB on a 32-bit x86 system.

This address space is split in half, the lower half (_0x00000000 - 0x7FFFFFFF_) is allocated to processes. The upper half (_0x80000000 - 0xFFFFFFFF_) is allocated to OS memory utilization. 

Administrators can alter this allocation layout for applications that require a larger address space through settings (_increaseUserVA_) or the [AWE (**A**ddress **W**indowing **E**xtensions)](https://docs.microsoft.com/en-us/windows/win32/memory/address-windowing-extensions).

The theoretical maximum virtual address space is 256 TB on a 64-bit modern system.

The exact address layout ratio from the 32-bit system is allocated to the 64-bit system

[Q] Compare 
- DLL Hijacking ([T1574.001](https://attack.mitre.org/techniques/T1574/001/))
- DLL Side-Loading ([T1574.002](https://attack.mitre.org/techniques/T1574/002/))
- DLL Injection ([T1055.001](https://attack.mitre.org/techniques/T1055/001/))

[Q] Compare 
- Process Injection ([T1055](https://attack.mitre.org/techniques/T1055/))
- Process Hollowing ([T1055.012](https://attack.mitre.org/techniques/T1055/012/))
- Process Masquerading ([T1055.013](https://attack.mitre.org/techniques/T1055/013/))

[More]  Introduction to Windows API [Room](https://tryhackme.com/room/windowsapi)

---
# Dissecting PE Headers

PE headers are of the data type [STRUCT](https://docs.microsoft.com/en-us/cpp/cpp/struct-cpp?view=msvc-170). A struct is a user-defined data type that combines several different types of data elements in a single variable. Since it is user-defined, we need to see the documentation to understand the type for each STRUCT variable.

IMAGE_DOS_HEADER :
start with : e_magic (0x5a4d MZ) and end with : e_lfanew
The MZ characters denote the initials of Mark Zbikowski
The Intel x86 architecture uses a little-endian format, while ARM uses a big-endian format.
The last value in the IMAGE_DOS_HEADER is called `e_lfanew`. In the above screenshot, it has a value of `0x000000d8`. This denotes the address from where the IMAGE_NT_HEADERS start.

 The DOS_STUB:
 The DOS STUB contains the message that we also see in the Hex Editor `!This program cannot be run in DOS mode`

IMAGE_NT_HEADERS :
	NT_HEADERS:
	- Signature
	- FILE_HEADER
	- OPTIONAL_HEADER


 the IMAGE_SECTION_HEADER has different sections, namely `.text`, `.rdata`, `.data`, `.ndata` and `.rsrc`.



---
# Basic Static Analysis

FLOSS uses several techniques to deobfuscate and extract strings that would not be otherwise found using a string search. The type of strings that FLOSS can extract and how it works can be found in [Mandiant's blog post](https://www.mandiant.com/resources/blog/automatically-extracting-obfuscated-strings).

Capa reads the files and tries to identify the behavior of the file based on signatures such as imports, strings, mutexes, and other artifacts present in the file.

---
# Basic Dynamic Analysis

API logger and API monitor tools which can help us identify what API calls malware is making.
The API Logger is a simple tool that provides basic information about APIs called by a process.
The API Monitor provides more advanced information about a process's API calls. API Monitor has 32-bit and 64-bit versions for 32-bit and 64-bit processes.

---

# Anti-Reverse Engineering

`Win32_TemperatureProbe` is a Windows Management Instrumentation (WMI) class that contains real-time temperature readings from the hardware through the SMBIOS (System Management BIOS) data structure. In a virtualized environment, the value returned is `Not Supported`, which is what malware looks for.

There are a lot of Packers available. Each has a unique approach and algorithm for packing. Here is a list of some that were seen used in the wild:

- [Alternate EXE Packer](https://www.alternate-tools.com/pages/c_exepacker.php?lang=ENG)
- [ASPack](http://www.aspack.com/) 
- [ExeStealth](https://unprotect.it/technique/exestealth/)
- [hXOR-Packer](https://github.com/akuafif/hXOR-Packer)
- [Milfuscator](https://github.com/nelfo/Milfuscator)
- [MPress](https://www.autohotkey.com/mpress/mpress_web.htm)
- [PELock](https://www.pelock.com/products/pelock)
- [Themida](https://www.oreans.com/Themida.php)
- [UPX: the Ultimate Packer for eXecutables](https://upx.github.io/)
- [VMProtect](https://vmpsoft.com/)


Here is a short list of scripts that you could use for specific Unpacker tools:

- [Themida](https://github.com/Hendi48/Magicmida)
- [Enigma Protector](https://github.com/ThomasThelen/OllyDbg-Scripts/blob/master/Enigma/Enigma%20Protector%201.90%20-%203.xx%20Alternativ%20Unpacker%20v1.0.txt)
- [Mpress unpacker](https://github.com/avast/retdec/blob/master/src/unpackertool/plugins/mpress/mpress.cpp)
- [unpac.me](https://www.unpac.me/)

Scylla is a tool that can dump process memory to disk and fix and rebuild the Import Address Table (IAT). We'll use this to dump the unpacked legitimate part of the program to memory and fix it so it will have the updated memory locations from its DLL imports.
