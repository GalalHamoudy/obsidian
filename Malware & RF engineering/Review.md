**PEB!IsDebugged** flag :

```
mov eax, fs:[30]
mov eax, [eax+2]
test eax, eax       ;(test=and)
jnz exit_debugger_detected
```

- `RDTSC` instructions (Read Time Stamp Counter). They generally come in pairs, followed by a comparison.

```
rdtsc          ;(eax = time stamp counter)
mov ebx, eax
  ... some measured code ...
rdtsc
sub eax, ebx
cmp eax, ... some tick count ...
jg detected_debugger
```


Often packer's stub start with `pusha`(push all general purpose register) and ends with `popa`(pop all registers) follow by a jump. The jump is at far location(mostly to other section of pe).  
After the jump you land to OEP. You can dump the unpacked code to new pe file using _ollydump_ plugin.


## Windows Functions and DLLs

- The strings **GetLayout** and **SetLayout** are Windows functions used by the Windows graphics library.
- **GDI32.DLL** is meaningful because it's the name of a common Windows dynamic link library (DLL) used by graphics programs.
- Packed and obfuscated code will often include at least the functions ==**LoadLibrary** and **GetProcAddress**==, which are used to load and gain access to additional functions.
- Several Microsoft Windows functions allow programmers to import linked functions not listed in a program's file header. Of these, the two most commonly used are **LoadLibrary** and **GetProcAddress**. **LdrGetProcAddress** and **LdrLoadDll** are also used. 
- **LoadLibrary** and **GetProcAddress** allow a program to access any function in any library on the system, which means that when these functions are used, you can't tell statically which functions are being linked to by the suspect program.
- Exploring Dynamically Linked Functions with **The Dependency Walker** program.
- The function **SetWindowsHookEx** is commonly used in spyware and is the most popular way that keyloggers receive keyboard inputs.

## Comparisons

### Compare between **CISC** and **RISC**.

|**Feature**|**CISC (Complex Instruction Set Computer)**|**RISC (Reduced Instruction Set Computer)**|
|---|---|---|
|**Instruction Set**|Large and complex, with many instructions.|Small and simple, with fewer instructions.|
|**Instruction Length**|Variable-length instructions.|Fixed-length instructions (e.g., 32-bit).|
|**Execution Time**|Some instructions take multiple clock cycles.|Most instructions execute in a single clock cycle.|
|**Hardware Complexity**|More complex hardware (microcode, decoders).|Simpler hardware, relies on software optimization.|
|**Memory Access**|Memory-to-memory operations allowed (e.g., `ADD [A], [B]`).|Load/Store architecture (only `LOAD`/`STORE` access memory).|
|**Registers**|Fewer general-purpose registers.|More general-purpose registers.|
|**Pipelining**|Difficult due to variable instruction lengths and complexity.|Easier to implement due to uniform instruction length.|
|**Code Size**|Smaller code size (denser instructions).|Larger code size (more instructions needed).|
|**Power Efficiency**|Less power-efficient due to complex decoding.|More power-efficient due to simplicity.|
|**Examples**|Intel x86, AMD64.|ARM, MIPS, RISC-V, PowerPC.|

### **Key Differences:**

1. **Philosophy:**
    - **CISC** focuses on reducing the number of instructions per program by making each instruction more powerful.
    - **RISC** focuses on reducing the complexity of each instruction, allowing faster execution.
2. **Performance:**
    - **CISC** can be slower due to complex decoding.
    - **RISC** is optimized for pipelining and faster execution.
3. **Use Cases:**
    - **CISC:** Desktop PCs, servers (x86).
    - **RISC:** Mobile devices, embedded systems (ARM).

## Compare between call convention **cdecl**, **fastcall**, **stdcall**.

| **Feature**            | **cdecl** (C Declaration)                    | **stdcall** (Standard Call)                | **fastcall** (Fast Call)                                       |
| ---------------------- | -------------------------------------------- | ------------------------------------------ | -------------------------------------------------------------- |
| **Argument Passing**   | Pushed onto the stack (right-to-left).       | Pushed onto the stack (right-to-left).     | First few args in registers (e.g., ECX, EDX), rest on stack.   |
| **Stack Cleanup**      | **Caller** cleans the stack (`add esp, X`).  | **Callee** cleans the stack (`ret X`).     | Mixed (registers don’t need cleanup, stack handled by callee). |
| **Variadic Functions** | Supports (e.g., `printf`).                   | **Not supported** (fixed args only).       | Usually not supported.                                         |
| **Performance**        | Slower (stack operations + caller cleanup).  | Faster than `cdecl` (callee cleans stack). | Fastest (fewer stack accesses).                                |
| **Common Usage**       | Default in C (x86).                          | Win32 API, Pascal.                         | Optimized code (x86), some Win32 APIs.                         |
| **Return Value**       | Typically in `EAX` (x86).                    | Typically in `EAX` (x86).                  | Typically in `EAX` (x86).                                      |
| **Example (x86)**      | `func(1, 2, 3);` → caller does `add esp, 12` | `func(1, 2, 3);` → callee does `ret 12`    | `func(1, 2, 3);` → ECX=1, EDX=2, stack=3                       |


### **Example Code (x86):**

#### **1. `cdecl` (Caller cleans stack)**

```
push 3      ; arg3  
push 2      ; arg2  
push 1      ; arg1  
call func   ; function call  
add esp, 12 ; caller cleans stack  
```

#### **2. `stdcall` (Callee cleans stack)**

```
push 3      ; arg3  
push 2      ; arg2  
push 1      ; arg1  
call func   ; function ends with `ret 12`  
; no cleanup needed  
```

#### **3. `fastcall` (Args in registers + stack)**

```
mov ecx, 1  ; arg1 in ECX  
mov edx, 2  ; arg2 in EDX  
push 3      ; arg3 on stack  
call func   ; function may clean stack
```


## PE (Portable Executable) Format

### ==Why PE?==

- It separates the code and the data in sections.
- Each section has separate memory permissions.
- The file is expandable in memory (less size on a hard disk).
- Supports dynamic linking and Supports relocation and Supports resource section.
- Portable for multiple processors, subsystems, and types of files.

### File Header

- Machine && NumberOfSections && TimeDateStamp && Characteristics.

### Optional Header

- Magic (whether it's x86 or x64). && AddressOfEntryPoint && ImageBase && SectionAlignment.
- FileAlignment && MajorSubsystemVersion && SizeOfImage && SizeOfHeaders && Subsystem.

### Data Directory

- The Data directory array points to the other optional headers that might be included in the executable and are not necessarily included in every application.
- The Data directory array includes many different values; not all of them are that important for malware analysis, but some of the important blocks to mention are as follows:
  - Import table && Export table && Resource table && Relocation table && TLS table.

### Section Table

- Following the 16 entries of the Data directory array come the section headers. This is a list of headers with each header representing a section of the PE file. The number of headers in total is the exact number stored in the **NumberOfSections** field in **FileHeader**.

### PE+ (x64 PE) compared to x86 PE

- ImageBase: It is 8 bytes instead of 4 bytes.
- BaseOfData: This was removed from the Optional header.
- Others: Some other fields, such as SizeOfHeapCommit, SizeOfHeapReserve, SizeOfStackReserve, and SizeOfStackCommit are now 8 bytes instead of 4 bytes.
- Magic: This value changed from 0x10B (representing x86) to 0x20B (representing x64).
- PE+ files stayed with the maximum 2 GB size, and all other RVA addresses, including AddressOfEntrypoint, remained 4 bytes.

## Using PE Header for Incident Handling

- Is this malware packed?
- Is this malware a dropper or a downloader?
- Does it connect to the Command & Control server(s) (C&C, or the attacker website)? And how?
- What functionalities does this malware have?

## Using PE Header for Threat Intelligence

- When was this sample created?
- What's the country of origin of these attackers?
- Is it a stolen certificate? Are all these samples related?

## Virtual Memory and Data Structures

- Virtual memory allows you to create a security layer between one process and another and allows the operating system to manage different processes and suspend one process to give resources to another.
- **Important data structures: TIB, TEB, and PEB**: They are all accessible through a special segment register FS, like this: `mov eax, DWORD PTR FS:[XX]`.
  - **Thread Information Block (TIB)**: Contains some information about the thread, including the list of functions that are used for error handling and much more.
  - **Thread Environment Block (TEB)**: Has more information about the thread, including the thread ID.
  - **Process Environment Block (PEB)**: Includes information about the process, such as the process name, process ID (PID), loaded modules (all PE files loaded in the memory including the program itself and its DLLs), and much more.

## ==Process Loading Step by Step==

1. Starting the program: that calls an API called CreateProcess, which gives the operating system the request to create this process and start the execution.
2. Creating the process data structures: in the kernel (which is called EProcess) and sets a unique ID for this process (ProcessID), and sets the explorer.exe process ID as a parent PID for the newly created file.exe process.
3. Initialize the virtual memory: Then, Windows creates the process, virtual memory and its representation of the physical memory and saves it inside the EProcess structure, creates the PEB structure with all necessary information, and then loads the main two DLLs ntdll.dll and kernel32.dll.
4. Loading the PE file: After that, Windows starts loading the PE file and loading all the required third-party libraries (DLLs), including all DLLs these libraries require.
5. Start the execution: Last but not least, Windows creates the first thread in the process, which does some initialization and calls the PE file's entry point to start the execution of the program.

## ==PE File Loading Step by Step==

1. Parsing the headers: parsing the DOS header to find the PE header and then parses the PE header (File header and Optional header) to gather some important information: ImageBase && NoOfSections && SizeOfImage.
2. Parsing section table.
3. Mapping the file in memory: Using SectionAlignment, the loader copies all the headers and then moves each section to a new place using its VirtualAddress and VirtualSize values.
4. Dealing with third-party libraries: In this step, the loader loads all the required DLLs, After that, it gets the addresses of all the required APIs and saves them in the import table of the loaded PE file.
5. Dealing with relocation: If has a relocation table, the loader fixes all the absolute addresses in the code with the new address of the program/library (with the new ImageBase).
6. Start the execution: In the last step, as in the process creation, Windows creates the first thread, which executes the program from its entry point.

## 32-bit in x64 Environment

- Windows has created the WOW64 emulator. This consists of the following three DLLs: wow64.dll && wow64cpu.dll && wow64win.dll.
- These DLLs basically create a simulated environment for the 32-bit process, which includes a 32-bit ntdll.dll and a 32-bit kernel32.dll.
- These DLLs, rather than connecting directly to the Windows kernel, call an API X86SwitchTo64BitMode, which then switches to x64 and calls the 64-bit ntdll.dll, which communicates directly to the kernel.

## Debugging Malicious Services

## Levels of Abstraction

The following six different levels of abstraction:

1. The hardware level is also known as digital logic.
2. The microcode level is also known as firmware.
3. The machine code level consists of opcodes.
4. A low-level language is a human-readable version of a computer architecture's instruction set.
5. High-level languages.
6. Interpreted languages.

## Heap and Stack

- **Heap**: The heap is used for dynamic memory during program execution, to create (allocate) new values and eliminate (free) values that the program no longer needs. The heap is referred to as dynamic memory because its contents can change frequently while the program is running.
- **Stack**: The stack is used for local variables and parameters for functions, and to help control program flow.

## Endianness

- `0x42000000` is treated as the value `0x42` because the x86 architecture uses the little-endian format. The endianness of data describes whether the most significant (big-endian) or least significant (little-endian) byte is ordered first (at the smallest address) within a larger data item. Changing between endianness is something malware must do during network communication, because **network data uses big-endian** and **an x86 program uses little-endian**. Therefore, the IP address `127.0.0.1` will be represented as `0x7F000001` in big-endian format (over the network) and `0x0100007F` in little-endian format (locally in memory). As a malware analyst, you must be cognizant of endianness to ensure you don't accidentally reverse the order of important indicators like an IP address.

## Register Operations

- `pusha` pushes the 16-bit registers on the stack in the following order: AX, CX, DX, BX, SP, BP, SI, DI.
- `pushad` pushes the 32-bit registers on the stack in the following order: EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI.

## Variables

- The global variables are referenced by memory addresses, and the local variables are referenced by the stack addresses.

## Calling Conventions

### cdecl

- Parameters are pushed onto the stack from right to left.
- The caller cleans up the stack when the function is complete, and the return value is stored in EAX.

### stdcall

- The popular stdcall convention is similar to cdecl, except stdcall requires the callee to clean up the stack when the function is complete.

### fastcall

- The first few arguments (typically two) are passed in registers, with the most commonly used registers being EDX and ECX.
- Additional arguments are loaded from right to left, and the calling function is usually responsible for cleaning up the stack.

## Windows Registry

The registry is split into the following five root keys:

- **HKEY_LOCAL_MACHINE (HKLM)**: Stores settings that are global to the local machine.
- **HKEY_CURRENT_USER (HKCU)**: Stores settings specific to the current user.
- **HKEY_CLASSES_ROOT**: Stores information defining types.
- **HKEY_CURRENT_CONFIG**: Stores settings about the current hardware configuration, specifically differences between the current and the standard configuration.
- **HKEY_USERS**: Defines settings for the default user, new users, and current users.

## Networking Functions

- The `WSAStartup` function must be called before any other networking functions in order to allocate resources for the networking libraries. When looking for the start of network connections while debugging code, it is useful to set a breakpoint on `WSAStartup`, because the start of networking should follow shortly.

## Variables and Calling Conventions (Recap)

- **Global Variables**: Referenced by memory addresses (e.g., `dword_40CF60`).
- **Local Variables**: Referenced by stack addresses (e.g., `ebp-4`).

### cdecl Convention

- One of the most popular. Params pushed onto stack from right to left, and caller cleans up the stack at end.

### stdcall Convention

- Similar to cdecl, except callee needs to clean up stack. This is the standard convention for the Windows API, and as such when calling them you don't need to clean up the stack as the DLLs which implement the API will clean up the stack.

### fastcall Convention

- Varies most across compilers. First couple of arguments are passed in registers (e.g., EDX or ECX). Any other arguments are loaded right to left. Calling function responsible for cleaning up stack. Generally faster.

## Exceptions

- **First Chance Exception**: If an exception handler is registered it first catches an error and can choose to handle it a certain way (e.g., by ignoring or passing to an output the user can see). This occurs when no debugger is attached.
- **Second Chance Exception**: If an exception occurs and it is passed as a second chance exception, it means a debugger will catch it and the program would have crashed if this wasn't the case.

## Identifying Packed Samples

### Technique 3: Using Stub Execution Signs

- Since most of the unpacked PE files start the execution from the first section (.text or .code), the packed PE files start the execution from one of the last sections, which is a clear indication that a decryption process will be running.
- The entry point is not pointing to the first section (it would mostly be pointing to one of the last two sections) and this section's memory permission is EXECUTE (in the section's characteristics).
- The first section's memory permission will be mostly READWRITE.

## Automatically Unpacking Packed Samples

- **Technique 1**: The official unpacking process.
- **Technique 2**: Using OllyScript with OllyDbg.
- **Technique 3**: Using generic unpackers (The QuickUnpack tool).
- **Technique 4**: Emulation.
- **Technique 5**: Memory dumps.

## Manual Unpacking Using OllyDbg

### Technique 6: Memory Breakpoint on Execution

Many packers encrypt the first few sections (including the code section), and the unpacker stub just unpacks each of them and then transfers control to the original entry point (OEP) for the application to run normally. We don't know the OEP, but we can easily assume that it's in the first section and that we can set a breakpoint to catch any execution of instructions there.

#### Step 1: Setting the Breakpoints

By going to View | Memory. Now, we can change the first section's memory permissions to READWRITE if it was Full access.

If the memory permissions don't include the EXECUTE permission. Therefore, you need to enforce what's called **Data Execution Prevention (DEP)**, which enforces the EXECUTE permission and doesn't allow any non-executable data to be executed.

#### Step 2: Turning on Data Execution Prevention

Changing DEP settings on Windows (you can go to Advanced system settings and then Data Execution Prevention. You will need to turn it on for all programs and services).

#### Step 3: Preventing Any Further Attempts to Change Memory Permissions

The unpacking stub can easily bypass this breakpoint by changing the permission of this section to full access again by using the `VirtualProtect` API.

If the stub tries to call `VirtualProtect` to change the memory permissions, the debugged process will break and you can change the permission it tries to set on the first section. You can change the NewProtect value to READONLY or READWRITE and remove the EXECUTE bit from it.

#### Step 4: Executing and Getting the OEP

### Technique 7: Call Stack Backtracing

We can set a breakpoint that we are sure will make the debugged process break in the middle of the execution of the decrypted code (the actual program code after the unpacking phase). Once the execution stops, we can backtrace the call stack and go back to the first call in the decrypted code. Once we are there, we can just slide up until we reach the start of the first function that was executed in the decrypted code, and we can declare this address as the OEP.

#### Step 1: Setting the Breakpoints

You need to set the breakpoints on the APIs that the program will execute at some point.

#### Step 2: Following the Call Stack

Follow the stored esp value in the stack and then the next stored esp value until you land on the first return address.

Now, follow the return address on the disassembled section in the CPU window.

Now, you have reached the first call in the unpacked section, and the only step left is reaching the OEP.

#### Step 3: Reaching the OEP

### Technique 8: Monitoring Memory Allocated Spaces for Unpacked Code

The idea here is that the original malware usually allocates a big block of memory in order to store the unpacked/decrypted embedded sample.

There are multiple Windows APIs that can be used for allocating memory in user mode. Attackers generally tend to use the following ones:

- `VirtualAlloc`/`VirtualAllocEx`
- `LocalAlloc`
- `GlobalAlloc`
- `HeapAlloc`

If the sample is written in C, it makes sense to monitor `malloc`/`calloc` functions straight away. For C++ malware, we can also monitor the `new` operator.

As long as we stop at the entry point of the sample (or at the beginning of the TLS routine, if it is available), we can set a breakpoint on execution to the following functions. Generally, it is OK to put a breakpoint on the first instruction of the function, but if there is a concern that malware can hook it (that is, replace the first several bytes with some custom code), the breakpoint at the last instruction will work better.

After this, we continue execution and keep monitoring the sizes of the allocated blocks. As long as it is big enough, we can put a breakpoint on the write access in order to intercept the moment when the encrypted (or already decrypted, on the fly) payload is being written there. If the malware calls one of these functions too many times, it makes sense to set a conditional breakpoint and monitor only allocations of blocks bigger than a particular size. After this, if the block is still encrypted, we can keep a breakpoint on writes and wait until the decryption routine starts processing it. Finally, we dump the memory block to disk when the last byte is decrypted.

### Technique 9: In-Place Unpacking

While definitely not common, it is possible to either decrypt the sample in the same section that it was originally located (this section should have write permissions) or in another section of an original file.

In this case, it makes sense to perform the following steps:

1. Search for a big encrypted block (usually, it has high entropy and is visible to the naked eye in a hex editor).
2. Find the exact place where it will be read (the first bytes of the block may serve other purposes---for example, they might store various types of metadata, such as sizes or checksums/hashes, to verify the decryption).
3. Put a breakpoint on read and/or write there.
4. Run the program and wait for the breakpoint to be triggered.

As long as this block is accessed by the decryption routine, it is pretty straightforward to get the decrypted version of it---either by placing a breakpoint on execution at the end of the decryption function or a breakpoint on write to the last bytes of the encrypted block to intercept the moment when they are processed.

### Technique 10: Stack Restoration-Based

Restoring the stack is usually quicker to do than the previous two techniques, but it is much less reliable. The idea here is that some packers keep the stack in order and transfer control to the unpacked sample when it has the same stack level that they started with. What that means is that it will access the value located at the address that was originally pointed by the frame pointer register (ebp/rbp), minus one value of a size of the address length for the selected architecture (for example, a 4-byte DWORD for a 32-bit platform) just before transferring control to the unpacked code, even when using the `jmp` instruction.

In this case, it is possible to set a breakpoint on access to the `[ebp-4]` value while staying at the entry point of the sample and then executing it so that the breakpoint will hopefully trigger just before transferring control to the unpacked code. Often, this happens when the packer restores the registers to the original values---for example, by using the `popad` instruction.

Obviously, this may never happen, depending on the implementation of the unpacking code, and there may be other situations where this does happen (for example, when there are multiple garbage calls before starting the actual unpacking process). Therefore, this method can only be used as a first quick check before more time is spent on the other methods, which will work in pretty much any case.

After we reach the point where we have the unpacked sample in memory, we need to save it to disk.

## Dumping the Process

Once you reach the OEP from the previous manual unpacking process, you can set the OEP as the new entry point. OllyDump has the ability to fix the import table (as we will soon describe). You can either use it or uncheck the Rebuild Import checkbox if you are willing to use other tools.

## Fixing the Import Table

What happens to the import table that needs to be fixed?

The answer is: when the PE file gets loaded in the process memory or the unpacker stub loads the import table, the loader goes through the Import Table header from the Data Directory and populates it with the actual addresses of API functions from DLLs that are available on the machine.

After this, these API addresses are used to access these APIs throughout the application code, usually by using `call` and `jmp` instructions.

To unload the import table, we need to find this list of API addresses, find which API each address represents (we need to go through each library list of addresses and their corresponding API names for this), and then replace each of these addresses with either an offset pointing to the API name string or an ordinal value. If we don't find the API names in the file, we may need to create a new section that we can add these API names to and use them to restore the Import Table.

Fortunately, there are tools that do this automatically. In this section, we will talk about the Import Reconstructor **(ImpREC)**:

1. Dump the process or any library you want to dump using, for example, OllyDump (and uncheck the Rebuild Import checkbox) or any other tool of preference.
2. Open ImpREC and choose the process you are currently debugging.
3. Now, set the OEP value to the correct value and click on IAT AutoSearch.
4. After that, click on Get Imports and delete any rows with valid: NO from the Imported Functions Found section.
5. Click on the Fix Dump button and then select the previously dumped file. Now, you will have a working, unpacked PE file. You can load it in PEiD or any other PE explorer application to check whether it's working.

## Identifying Encryption Functions

To identify an encryption function, there are four things you should be searching for:

1. Sequential data read.
2. Encrypting the value.
3. Sequential data write.
4. Loop.

## The RC4 Encryption Algorithm

The RC4 algorithm is a symmetric algorithm that uses one secret key (maximum of 256 bytes). The algorithm consists of two parts, a **key-scheduling algorithm (KSA)** and a **pseudo-random generation algorithm (PRGA)**. Let's have a look at each of them in greater detail.

### Key-Scheduling Algorithm (KSA)

The key-scheduling part of the algorithm basically creates an array of 256 bytes from the secret key, which is just another, bigger version of the key. This array will be the key that is used to encrypt and decrypt the data afterwards. This part consists of the following two parts:

1. It creates an array with values from 0 to 256 sequentially.
2. It swaps bytes based on the key---this generates an index number, j, based on the secret key.

### Pseudo-Random Generation Algorithm (PRGA)

The pseudo-random generation part of the algorithm just generates pseudo-random values (again, based on swapping bytes, like we did for the key), but also performs a XOR operation with the generated value and a byte from the data.

### Identifying RC4 Algorithm

To identify an RC4 algorithm, there are some key characteristics that can help you detect it rather than you having to spend hours trying to analyze each part of the algorithm:

- The generation of the 256 bytes array.
- There's lots of swapping.
- The actual algorithm is XOR.
- Encryption and decryption similarity.

## Steps for Encryption/Decryption Using Windows CryptoAPI

We will take a look at the steps malware has to go through to encrypt or decrypt its data using any of these algorithms and how to identify the exact algorithm that's used, as well as the secret key:

### Step 1: Initializing and Connecting to the Cryptographic Service Provider (CSP)

For the malware sample to initialize and use one of these providers, it executes the `CryptAcquireContext` API.

### Step 2: Preparing the Key

1. First, the author uses their plain text key and hashes it using any of the known hashing algorithms, such as MD5, SHA128, SHA256.

   ```asm
   CryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash);
   CryptHashData(hHash, secretkey, secretkeylen, 0);
   ```

2. Then, they create a session key from this hash using `CryptDeriveKey`---for example:

   ```asm
   CryptDeriveKey(hProv, CALG_3DES, hHash, 0, &hKey);
   ```

   From here, they can easily identify the algorithm from the second argument value that's provided to this API.

3. Some malware authors use a KEYBLOB, which includes their key, with `CryptImportKey`. A KEYBLOB is a simple structure that contains the key type, the algorithm that was used, and the secret key for encryption.

### Step 3: Encrypting or Decrypting the Data

The malware uses `CryptEncrypt` or `CryptDecrypt` to encrypt or decrypt the data.

### Step 4: Freeing the Memory

This is the last step, where we free the memory and all the handles that have been used by using the `CryptDestroyKey`, `CryptDestroyHash`, and `CryptReleaseContext` APIs.

## Cryptography API Next Generation (CNG)

Used to implement encryption algorithms, which is a new set of APIs that have been implemented by Microsoft.

The steps for using them are as follows:

1. Initialize the algorithm provider:

   ```asm
   BCryptOpenAlgorithmProvider(&hAesAlg, BCRYPT_AES_ALGORITHM, NULL, 0)
   ```

2. Prepare the key: This API may use an imported key or generate a key.

   This can help you extract the secret key that's used for encryption, like so:

   ```asm
   BCryptGenerateSymmetricKey(hAesAlg, &hKey, pbKeyObject, cbKeyObject, (PBYTE)SecretKey, sizeof(SecretKey), 0)
   ```

3. Encrypt or decrypt data: In this step, you can easily identify the start of the data blob to be encrypted (or decrypted):

   ```asm
   BCryptEncrypt(hKey, pbPlainText, cbPlainText, NULL, pbIV, cbBlockLen, NULL, 0, &cbCipherText, BCRYPT_BLOCK_PADDING)
   ```

4. Cleanup: This is the last step, and uses APIs such as `BCryptCloseAlgorithmProvider`, `BCryptDestroyKey`, and `HeapFree` to clean up the data.

## Process Injection

For malware authors, process injection helps them to do the following:

- Bypass trivial firewalls that block internet connections from all applications except browsers or other allowed apps.
- Evade debuggers and other dynamic analysis or monitoring tools.
- Hook APIs in the legitimate process the malware injected its code into.
- Maintain persistence for fileless malware.

### AppInit_DLLs

In Windows 7, it requires DLLs to be signed and it's disabled by default for Windows 8 and beyond. However, it still can be misused by setting the `RequireSignedAppInit_DLLs` value to `False` and `LoadAppInit_DLLs` value to `True`. Attackers require administrative privileges to be able to set these entries.

### Simple DLL Injection Technique

Inject the path of the malicious DLL into the process using the `VirtualAllocEx` API and `WriteProcessMemory`. Then, it creates a thread into that process using `CreateRemoteThread`, with the address of the `LoadLibrary` API as the thread start address.

The exact steps the malware generally follows are like so:

1. Get the targeted process handle via its PID using the `OpenProcess` API.
2. Allocate a space in that process virtual memory using the `VirtualAllocEx` API.
3. Write a path of the malware DLL to the process using the `WriteProcessMemory` API.
4. Load and execute this DLL using `CreateRemoteThread` and provide the `LoadLibraryA` address as the start address, and the address of the DLL path as an argument.

This technique leaves traces of the malicious DLL in the process information. Any simple tool such as `listdlls.exe` from Sysinternals Suite can help incident response engineers to detect this malicious behavior.

### Getting the List of Running Processes

1. Create a snapshot of all of the processes running at that moment.
2. Get the first process in this list using the `Process32First` API.
3. Loop on the `Process32Next` API to get each process in the list, one by one, with its name and process ID.

### Code Injection Technique

The steps that the malware follows for this code injection technique are like so:

1. Search for the targeted process using `CreateToolhelp32Snapshot`, `Process32First`, and `Process32Next`.
2. Get the process handle using the `OpenProcess` API.
3. Allocate memory inside this process using `VirtualAllocEx` with the size of the whole piece of the assembly code to be injected.
4. Copy that code into the targeted process using `WriteProcessMemory`, as we have seen already.
5. Execute this code using the `CreateRemoteThread` API.

### Process Hollowing

Process hollowing is simply a matter of removing the targeted process's PE memory image from its virtual memory and replacing it with the malware executable file.

The process of this form of code injection is quite different from the previous ones. Here are the steps the malware has to take in order to do this:

1. Create a legitimate process in suspended mode.
2. Unload the legitimate application's memory image using `VirtualFreeEx` (hollowing out the process).
3. Allocate the same space in memory (the same as the unloaded PE image) for the malware PE image (the `VirtualAllocEx` API allows the malware to choose the preferred address to be allocated if it's free).
4. Inject the malware executable into that space by loading the PE file and fixing its import table (resolving its relocation table if needed).
5. Change the thread's starting point to the malware's entry point using the `SetThreadContext` API.
6. The last step is to resume this suspended thread to execute the malware from that point.


process hollowing:
1- create legit proc in suspend mode
2- remove legit app PE by "VirtualFreeEx" and allocate this space by "VirtualAllocEx" 
3- inject mal pe 
4- fix : (import table , relocation table , threat starting point)
5- resume this suspended thread


## Dynamic Analysis of Code Injection

### Technique 1: Debug It Where It Is

- Once the malware calls `VirtualAllocEx` to allocate space for the shellcode in the targeted process memory, save the returned address of that allocated space.
- Set a breakpoint on `WriteProcessMemory` and save the source and the destination addresses.
- Now, set a breakpoint on `CreateRemoteThread` and get the entry point (and the arguments, if there are any) of that shellcode in the targeted process.
- Now, calculate the entry point's address inside the malware process's memory.
- If a virtual machine is used for debugging (which is definitely recommended), save a snapshot and then set the EIP value to the shellcode's EntryPoint, set any necessary arguments, and continue debugging from there.

This works only with simple shellcodes and doesn't work properly with multiple injections (multiple calls of `WriteProcessMemory`), process hollowing, or with complicated arguments.

### Technique 2: Attach to the Targeted Process

To be able to do so, we need to know the targeted process that the malware will inject into. This means that we need to set breakpoints on the `Process32First` and `Process32Next` APIs and analyze the code in-between searching for the APIs, such as `strcmp` or equivalent code, to find the required process to inject into. Not all calls are just for process injection.

### Technique 3: Dealing with Process Hollowing

The previous two techniques don't work with process hollowing. In process hollowing, the malware creates a new process in a suspended state, which makes it unseen by OllyDbg and similar debuggers.

The simplest way to deal with this is to set a breakpoint on `WriteProcessMemory` and dump the PE file before it's loaded into the targeted process memory. Once the breakpoint is triggered, follow the source argument of `WriteProcessMemory` and scroll up until the start of the PE file is found (usually, it can be recognized by the MZ signature).

## Memory Forensics Techniques for Process Injection

### Technique 1: Detecting Code Injection and Reflective DLL Injection

The main red flags that help in detecting injected code inside a process is that the allocated memory that contains the shellcode or the loaded DLL is always allocated with EXECUTE permission and doesn't represent a mapped file.

It's not common to see private allocated memory having the EXECUTE permission, and it's also not common to have the WRITE permission with the EXECUTE permission.

In Volatility, there is a command called `malfind`. This command finds hidden and injected code.

We can dump all memory images inside this process using the `vaddump` command.

### Technique 2: Detecting Process Hollowing

In Volatility, there are two commands that you can use to get a list of all of the loaded modules inside a process. One command lists the loaded modules from the PEB information (from user mode), which is `dlllist`, and the other one lists all loaded modules from EPROCESS kernel object information (kernel mode), which is `ldrmodules`. Any mismatch in the results between both commands could represent a hollow process injection.

### Technique 3: Detecting Process Hollowing Using the HollowFind Plugin

There is a plugin called `HollowFind` that combines all of these commands. It finds a suspicious memory space or evidence of a hollowed out process and returns these results.

## Understanding API Hooking

API hooking is a common technique that's used by malware authors to intercept calls to Windows APIs in order to change the input or output of these commands. It is based on the process injection technique.

### Inline API Hooking

To hook an API, the malware generally prefers to modify the first few bytes (typically, this is five bytes) of the API assembly code and replace them with `jmp <hooking_function>` so that it can change the API arguments and maybe skip the call to this API and return a fake result (like an error or just NULL).

### Inline API Hooking with Trampoline

When you're using trampolines, the malware can also alter the return value of the API and any data associated with it. The trampoline is simply a small function that only executes `jmp` to the API and includes the first missing five bytes (or three instructions, in the previous case).

### Inline API Hooking with a Length Disassembler

As we have seen in the previous techniques, API hooking is quite simple when you use the `mov edi, edi` instruction at the beginning of each API, which makes the first five bytes predictable for API hooking functionality. Unfortunately, this can't always be the case with all Windows APIs, so sometimes malware families have to disassemble the first few instructions to avoid breaking the API.

Some malware families such as Vawtrak use a length disassembler to replace a few instructions (with a size equal or greater than five bytes) with the `jmp` instruction to the hooking function. Then, they copy these instructions to the trampoline and add a `jmp` instruction to the API.

The main goal of this is to ensure that the trampoline doesn't `jmp` back to the API in the middle of the instruction and to make the API hooking work seamlessly without any unpredictable effects on the hooked process behavior.

## Detecting API Hooking Using Memory Forensics

We can use a Volatility command called `apihooks`. This command scans the process's libraries, searching for hooked APIs (starting with `jmp` or a `call`), and shows the name of the hooked API and the address of the hooking function.

We can then use `vaddump` (as we described earlier in this chapter) to dump this memory address and use IDA Pro or any other static analysis tool to disassemble the shellcode and understand the motivation behind this API hooking.

## Exploring IAT Hooking

IAT hooking (import address table hooking) is another form of API hooking that isn't widely used.

This hooking technique doesn't require any disassembler, code patching, or a trampoline.

The idea behind it is to modify the import table's addresses so that they point to the malicious hooking functions rather than the actual API. In this case, the hooking function executes `jmp` on the actual API address (or `call` after pushing the API arguments to the stack) and then returns to the actual program.

This hooking is not effective against the dynamic loading of APIs (using `GetProcAddress` and `LoadLibrary`), but it's still effective against many legitimate applications that have most of their required APIs in the import table.

## Debugger Detection Techniques

### Direct Check for Debugger Presence

There are multiple APIs that help detect whether the current process is being debugged or not, as follows:

- `IsDebuggerPresent`
- `CheckRemoteDebuggerPresent`
- `NtQueryInformationProcess` (with the `ProcessDebugPort (7)` argument)

These APIs access a flag in the process environment block (PEB) called `BeingDebugged` that is set to `True` when the process is running under a debugger.

## Debugger Detection Techniques

### Detecting a Debugger Through an Environment Change

- `NtGlobalFlag` is a flag at offset `0x68` of the PEB in 32-bit systems and `0xBC` in 64-bit systems.

### Detecting a Debugger Using Parent Processes

There are two common techniques for malware to get the parent process ID:

1. Looping through the list of running processes.
2. Using the undocumented `NtQueryInformationProcess` API. Given `ProcessBasicInformation` as an argument, this API can return the parent process ID.

There are two common ways to get the process name from its ID:

1. Looping through the processes the same way to get the parent process ID.
2. Using the `GetProcessImageFileNameA` API to get the filename of a process given its handle. To do this, they need to execute the `OpenProcess` API in order to get permission to access this process to query for information (by using `PROCESS_QUERY_INFORMATION` as the requested permissions argument).

### Detecting Software Breakpoints (INT3)

There are two other techniques that are commonly used by malware to scan for an INT3 breakpoint:

1. Precalculating a checksum for the entire code section and recalculating it again in execution mode.
2. Reading the malware sample file and comparing the code section from the file to the memory version of it. (This technique is not widely used as it's not effective if the malware sample has its relocation table populated.)

### Detecting Single-Stepping Breakpoints (Trap Flag)

#### Detecting a Trap Flag Using the SS Register

Your debugger cursor will move from `POP SS` to `MOV EAX, 1`, skipping the `PUSHFD` instruction, even if it was executed:

```asm
PUSH SS
POP SS
PUSHFD           ; Your debugger wouldn't stop on this instruction
MOV EAX,1        ; Your debugger will automatically stop on this instruction.
```

#### Detecting Single-Stepping Using Timing Techniques

There is an x86 instruction called `rdtsc` that returns the time in EDX:EAX registers. By calculating the difference between the time before and after executing a certain instruction, any delay will be clearly shown, which represents reverse-engineering tracing through the code.

This instruction is not the only way to get the time at any given moment. There are multiple APIs supported by Windows that help programmers get the exact time, as follows:

- `GetLocalTime`
- `GetSystemTime`
- `GetTickCount`
- `KiGetTickCount` (in kernel mode)
- `QueryPerformanceCounter`
- `timeGetTime`
- `timeGetSystemTime`

## Evading Hardware Breakpoints

### What is Structured Exception Handling?

For any program to handle exceptions, Windows provides a mechanism called SEH. It's based on setting a callback function to handle the exception and then resume execution.

If this callback failed to handle the exception, it can pass this exception to the previous callback that was set. If the last callback was unable to handle the exception, the operating system terminates the process and informs the user about the unhandled exception, and often suggests him or her to send it to the developer company.

The setup of the SEH callback generally looks like this:

```asm
PUSH <callback_func>    ; Address of the callback function
PUSH FS:[0]             ; Address of the previous callback item in the list
MOV FS:[0],ESP          ; Install the new EXCEPTION_REGISTRATION
```

### Detecting and Removing Hardware Breakpoints

- To detect or remove hardware breakpoints, malware can use SEH to get the thread context, check the values of the DR registers and clear all of them to remove the hardware breakpoints—or at least just check their values and exit if a debugger is detected.
- Another way to remove hardware breakpoints is to use the `GetThreadContext()` API to access the current thread (or another thread) context and check for the presence of hardware breakpoints or clear them using the `SetThreadContext()` API.

### Memory Breakpoints

Memory breakpoints can be easily detected by using the `ReadProcessMemory` API with the malware's `ImageBase` as an argument and the `SizeOfImage` as the size. `ReadProcessMemory` will return `False` if any page inside the malware is guarded (`PAGE_GUARD`) or set to no-access protection (`PAGE_NOACCESS`).

For a malware sample to detect a memory breakpoint on write or execute, it can query any memory page protection using the `VirtualQuery` API. Alternatively, it can evade them by using `VirtualProtect` with `PAGE_EXECUTE_READWRITE` argument.

### Escaping the Debugger by Process Injection

A commonly used solution to bypass this trick is to inject an infinite loop into the entry point of the injected code before it gets executed, usually in the injector code either before the `WriteProcessMemory` call when the code hasn't been injected yet or before `CreateRemoteThread`, this time in another process's memory.

An infinite loop can be created by writing two bytes (`0xEB 0xFE`) that represent a `jmp` instruction to itself.

### Windows Events Callbacks

Callbacks are each called for a specific event (like a mouse click, keyboard keystroke, or a window moving to the front). If you are single stepping over the malware instructions, the callback would still be executed without you noticing.

There are so many ways to set callback functions. Therefore, we will just mention two of them here:

1. Using the `RegisterClass` API.
2. Using `SetWindowLong`.

## Anti-Disassembling Tricks

- **Encryption**
- **Junk Code Insertion**: With this technique, the malware author inserts lots of code that never gets executed, either after unconditional jumps, calls that never return, or conditional jumps with conditions that would never be met.
- **Code Transportation**: It rearranges the code inside each subroutine with lots of unconditional jumps, including `call` and `pop` or conditional jumps that are always true.
- **Dynamic API Calling with Checksum**: They hide API names from static analysis tools and make it harder to understand what each function inside the malware does.
- **Proxy Functions and Proxy Argument Stacking**: With the proxy functions technique, malware doesn't directly call the required function; instead, it calls a proxy function that calculates the address of the required function and transfers the execution there.

## Detecting and Evading Behavioral Analysis Tools

### Finding the Tool Process

Loop through all the running processes and detect any unwanted entries.

### Searching for the Tool Window

Search for its window name (the window's title). By searching for a program window name, malware can bypass any renaming that could be performed on the process name, which gives it an opportunity to detect new tools as well.

This trick can be done in the following two ways:

1. Using `FindWindow`.
2. Using `EnumWindows`.

### Detecting Sandboxes and Virtual Machines

Different output between virtual machines and real machines:

- **CPUID Hypervisor Bit**: The `CPUID` instruction returns information about the CPU and provides a leaf/ID of this information in `eax` (indicating that the operating system is running inside a virtual machine or a hypervisor).
- **Virtualization Brand**: With the `CPUID` instruction, for some virtualization tools, given `eax = 0x40000000`, it could return the name of the virtualization tool.
- **MMX Registers**: MMX registers are a set of registers that were introduced by Intel that help speed up graphics calculations. Some virtualization tools don't support them. Some malware or packers use them for unpacking in order to detect or avoid running on a virtual machine.

### Detecting Virtualization Processes and Services

**VMware:**
- `vmtoolsd.exe`
- `vmacthlp.exe`
- `VMwareUser.exe`
- `VMwareService.exe`
- `VMwareTray.exe`

**VirtualBox:**
- `VBoxService.exe`
- `VBoxTray.exe`

### Detecting Virtualization Through Registry Keys

- `HKLM\SOFTWARE\Vmware Inc.\Vmware Tools`
- `SYSTEM\CurrentControlSet\Control\VirtualDeviceDrivers`
- `HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Class\{4D36E968-E325-11CE-BFC1-08002BE10318}\0000\ProviderName`
- `HKEY_LOCAL_MACHINE\HARDWARE\ACPI\DSDT\VBOX__`
- `HKEY_LOCAL_MACHINE\SOFTWARE\Oracle\VirtualBox Guest Additions`

### Detecting Virtual Machines Using PowerShell

This information can also be accessed through a WMI query, such as the following:

```sql
SELECT * FROM Win32_ComputerSystem WHERE Manufacturer LIKE "%VMware%" AND Model LIKE "%VMware Virtual Platform%"
```

For Microsoft Hyper-V, it would be as follows:

```sql
SELECT * FROM Win32_ComputerSystem WHERE Manufacturer LIKE "%Microsoft Corporation%" AND Model LIKE "%Virtual Machine%"
```

These techniques make it harder to hide the fact that this malware is running inside virtualization software and not on a real machine.

## Shellcode Analysis

### Linux Shellcode Challenges (x86-64)

The main challenges in Linux shellcode in x86-64 that attackers face are as follows:

1. Getting the absolute address of the shellcode (to be able to access data)
2. Removing any null byte that can be produced from the shellcode (optional)

### Windows Shellcode Execution Steps

Windows shellcodes follow these steps to achieve their target:

1. Get the absolute address (covered in previous sections)
2. Get the `kernel32.dll`'s ImageBase
3. Get the required APIs from `kernel32.dll`
4. Execute the payload

### Shellcode Analysis Tools

It is also possible to use tools such as:
- **libemu**: A small emulator library for x86 instructions
- **Pokas x86 Emulator**: Part of the pySRDF project, to emulate shellcode
- **shellcode2exe.py**: Script that converts shellcode into an executable file (supports multiple platforms)

## Memory Protection Techniques

### Data Execution Prevention (DEP)

Data execution prevention is one of the earliest techniques that was introduced to provide protection against exploits and shellcode.

### Return-oriented Programming (ROP)

They invented a new technique to bypass DEP or NX called Return-oriented Programming (ROP) for this purpose.

### Address Space Layout Randomization (ASLR)

For ASLR to be effective:
- Application and all its libraries must be compiled with ASLR enabling flag
- Common compiler flags: `-fstack-protector` or `-pie -fPIE` for gcc compiler

**Note**: If at least one module doesn't support ASLR, it becomes possible for the attacker to find the required ROP gadgets there.

## ==Document Analysis Tools==

### Office Document Analysis (oletools)

A unique set of several powerful tools that allow an analyst to analyze all common documents associated with Microsoft Office products:

| Tool | Description |
|------|-------------|
| olebrowse | Basic GUI tool for browsing CFB documents |
| oledir | Displays directory entries within CFB files |
| olemap | Shows all sectors present in the document, including the header |
| oleobj | Extracts embedded objects from CFB files |
| rtfobj | Same functionality as oleobj but for RTF documents |
| oledump | Powerful tool for analyzing document streams with dumping/decompression options |
| rtldump | Facilitates analysis of RTF documents |
| OfficeMalScanner | Features heuristics to search for shellcode entries and encrypted MZ-PE files |

### PDF Analysis Tools

| Tool | Description |
|------|-------------|
| pdf-parser | Versatile Swiss knife tool for PDF analysis |
| peepdf | Provides commands to identify, extract, decode, and beautify PDF data |
| PDFStreamDumper | Focused on extracting and processing payloads hidden in streams |
| malpdfobj | Generates JSON containing extracted/decoded information from malicious PDFs |

## .NET Analysis Tools

Here are the most well-known tools for decompiling and analyzing .NET malware:

| Tool | Capabilities |
|------|-------------|
| ILSpy | Good decompiler for static analysis (no debugging) |
| Dnspy | Decompiler with debugging and patching capabilities |
| .NET Reflector | Commercial decompiler with Visual Studio integration |
| .NET IL Editor (DILE) | Disassembler and debugger for .NET apps |
| dotPeek | Decompiles to C# code, good for static analysis |
| Visual Studio | Main IDE for .NET languages with debugging |
| SOSEX | WinDbg plugin for simplified .NET debugging |
| de4dot | Deobfuscator for known obfuscation tools |
| NoFuserEx | Deobfuscator specifically for ConfuserEx |
| Detect It Easy (die) | Detects obfuscators used in samples |

## Python Malware Analysis

### Python Compiled File Types

There are three types of compiled files associated with Python:

| Extension | Description |
|-----------|-------------|
| .pyc | Standard compiled bytecode files (faster module importing) |
| .pyo | Optimized bytecode files (built with -O/-OO flags) |
| .pyd | Windows DLL files with MZ-PE structure (.so on Linux) |

### Python Analysis Tools

| Tool | Description |
|------|-------------|
| unpy2exe.py | Handles samples built using py2exe |
| pyinstxtractor.py | Extracts Python modules from PyInstaller executables |
| uncompyle6 | Open source Python decompiler (supports multiple versions) |
| Decompyle++ (pycdc) | C++ disassembler/decompiler for Python bytecode |
| Meta | Python framework for bytecode and syntax tree analysis |
| UnPyc | Python disassembler/decompiler (project suspended) |


