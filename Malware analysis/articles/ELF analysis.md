use **readelf** to inspect the ELF header and obtain the exact entry point address. This tells me where execution starts when the binary is loaded.

to check how many sections in the binary contain executable code. I use **objdump -h** to list all sections, then filter for CODE using grep
command used: 
`objdump -h RotaJakiro.malware | grep CODE`

to know how the malware finds its own path. I search for known functions like [**readlink**, **realpath**, **/proc/self/exe**, or **getcwd**] using strings and grep.
command used: 
`strings RotaJakiro.malware | grep -E ‘readlink|realpath|/proc/self/exe|getcwd’`

To detect where the malware copies itself for persistence, I run it in a restricted folder using **strace** to log all system calls.
command used: 
`strace -f -o strace.log ./RotaJakiro.malware`

---

ELF (Executable and Linkable Format) analysis is the domain of Linux/Unix malware analysis. The methodology shifts significantly from document analysis to deep binary and system-level investigation.

---

### Core Concepts of ELF Malware

ELF is the standard binary format on Linux, Android, and many other Unix-like systems. Malicious ELF files can be:
*   **Standalone executables** (e.g., backdoors, miners, ransomware)
*   **Shared libraries** (`.so` files) injected via `LD_PRELOAD`
*   **Script interpreters** (e.g., a malicious binary that runs a Perl/Python script payload)

Common threats include **botnets (Mirai, IoT focused), cryptominers (XMRig), rootkits, and ransomware**.

---

### The ELF Malware Analysis Toolkit

The Linux environment provides powerful native tools. Your analysis will be a mix of static, dynamic, and memory analysis.

#### **Phase 1: Initial Triage & Basic Static Analysis**

**Goal:** Get a quick overview of the file without executing it.

1.  **`file` Command:** Identifies the file type. Is it a 32-bit or 64-bit ELF? Stripped?
    *   `file malware.bin`
    *   *Output example:* `malware.bin: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped`

2.  **`strings` Command:** Extracts human-readable strings. Look for:
    *   Command & Control (C2) domains/IPs, hardcoded paths (`/tmp/`), commands (`/bin/sh`, `chmod 777`).
    *   Library functions (`system`, `execve`), environment variables (`LD_PRELOAD`).
    *   *Command:* `strings -n 8 malware.bin | less` (`-n 8` shows strings at least 8 chars long)

3.  **`ldd` Command:** Lists shared libraries required by the executable. A **statically linked** binary (shows `not a dynamic executable`) is common in malware to ensure it runs on any system.
    *   `ldd malware.bin`

4.  **`readelf` Command:** A powerful Swiss Army knife for inspecting the ELF structure.
    *   `readelf -h malware.bin` (View the ELF header)
    *   `readelf -S malware.bin` (List sections - look for unusual names or missing sections like `.symtab` if stripped)
    *   `readelf -s malware.bin` (List symbols - useful if not stripped)
    *   `readelf -d malware.bin` (View dynamic segment - shows needed libraries)

5.  **`objdump` Command:** Disassembles sections. Use it to view the code.
    *   `objdump -d malware.bin | less` (Disassemble all executable sections)
    *   `objdump -x malware.bin` (Display all header information)

6.  **`nm` Command:** Lists symbols from the object file (only works if **not stripped**).
    *   `nm -D malware.bin` (For dynamic symbols)

#### **Phase 2: Advanced Static Analysis**

**Goal:** Deeper inspection, often with specialized tools.

1.  **Disassemblers & Decompilers:**
    *   **Ghidra (NSA):** The industry standard for free reverse engineering. It disassembles and **decompiles** code back to a C-like pseudocode, which is invaluable for understanding logic.
    *   **IDA Pro:** The commercial benchmark. Powerful disassembler and debugger.
    *   **Binary Ninja:** A modern and user-friendly alternative.
    *   **Process:** Load the binary, analyze it, and look for the `main` function. Trace system calls and network functions.

2.  **Packers & Cryptors Detection:**
    *   **`packerid` / `pestudio` (on Linux):** Tools to detect if the ELF is packed/encrypted (e.g., UPX). Signs of packing include a very small code section and unusual entry point.
    *   **UPX itself:** Often, malware is packed with UPX. You can try to unpack it: `upx -d malware.bin`. (But beware: some malware uses modified UPX headers to break automated unpacking).

#### **Phase 3: Dynamic Analysis (Behavioral)**

**Goal:** Run the malware in a controlled environment and observe its behavior.

**CRITICAL: Use an isolated Linux VM (e.g., Ubuntu server) with no network access to the outside world.**

1.  **System Call Tracing:**
    *   **`strace`:** **Essential.** Traces system calls (file, process, network operations).
        *   `strace -f -s 10000 -o trace.txt ./malware.bin` (`-f` follows forks, `-s` increases string length, `-o` saves to file)
    *   **`ltrace`:** Traces library calls. Useful for seeing what functions are called.
        *   `ltrace -f -o lib_trace.txt ./malware.bin`

2.  **Process and Network Monitoring:**
    *   **`ps`:** Monitor running processes. `ps auxf` shows a forest view.
    *   **`top` / `htop`:** Monitor system resource usage (CPU for cryptominers).
    *   **`netstat` / `ss`:** Monitor network connections. `netstat -tunap`
    *   **`lsof`:** Lists open files and network connections for a process.
        *   `lsof -p <PID_of_malware>`

3.  **Filesystem Monitoring:**
    *   **`inotifywait`:** Can monitor a directory for file changes (create, modify, delete).
    *   **Manual Checks:** Check common directories: `/tmp/`, `/dev/shm/`, and the current working directory.

4.  **Network Analysis:**
    *   **`tcpdump` / `wireshark`:** Packet capture. Run `tcpdump` on your dummy interface to see if the malware attempts any network communication.
    *   **Fake Internet with `inetd` or `INetSim`:** Set up a service to simulate DNS, HTTP, etc., and see what the malware tries to connect to.

#### **Phase 4: Advanced & Memory Analysis**

1.  **Debugging:**
    *   **`gdb` (GNU Debugger):** The standard. Allows you to step through execution, set breakpoints, and examine memory/registers. Use plugins like **GEF** or **Pwndbg** to enhance its capabilities dramatically.
    *   **`edb` (Evan's Debugger):** A graphical debugger similar to OllyDbg on Windows.

2.  **Memory Forensics:**
    *   **`Volatility`:** The premier tool for analyzing memory dumps. You can dump the memory of your VM after running the malware and then use Volatility to:
        *   List processes (`linux_pslist`).
        *   Dump a process's memory for strings analysis (`linux_dump_map`).
        *   Look for rootkits (`linux_check_modules`).
        *   Recover bash history (`linux_bash`).

### Important Tips for ELF Analysis

*   **Start Simple:** Always run `file`, `strings`, and `ldd` first. This gives you a 10,000-foot view.
*   **It's Probably Stripped:** Assume the binary is stripped (no symbols). Ghidra will be your best friend for making sense of the code.
*   **Look for Anti-Analysis:** Malware may check for debuggers (`ptrace`), VM artifacts, or if it's running in a specific directory.
*   **IoT Malware is Common:** Much Linux malware targets IoT devices (routers, cameras). It's often cross-compiled for non-x86 architectures (ARM, MIPS). Use `readelf -h` to check the architecture. You'll need tools like `qemu-user` to emulate and run it on your x86 analysis machine.
*   **Focus on System Calls:** The `strace` output is a goldmine. Look for `execve`, `connect`, `open`, `chmod` to understand the malware's actions.

**Summary Workflow:**
1.  **Triage:** `file`, `strings`, `ldd`, `readelf`.
2.  **Static Analysis:** Load into **Ghidra**. Find `main` and analyze key functions.
3.  **Dynamic Analysis:** Run in an isolated VM with **`strace`** and **`tcpdump`** active.
4.  **In-depth:** Use **`gdb`** with GEF/Pwndbg for debugging tricky parts, and **Volatility** for memory analysis if necessary.
5.  **Document IOCs:** Hashes, C2 IPs/domains, filenames created, and persistence mechanisms (cron jobs, init scripts).
