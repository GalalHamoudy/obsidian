The core difference: PDFs are not about executing VBA code. They are about **exploiting vulnerabilities** in the PDF reader software (like Adobe Acrobat Reader) or using social engineering to trick the user into executing a separate file.

---

### How PDFs Can Be Malicious

1.  **Exploits:** The PDF contains specially crafted code designed to trigger a software vulnerability (a bug) in the PDF parser. A successful exploit allows the attacker to run their own code on your system, often leading to a full compromise. This is less common now due to improved sandboxing.
2.  **JavaScript (PDF JS):** PDFs can contain embedded JavaScript. This is the most common method today. The JS is not an exploit itself but is used for:
    *   **Social Engineering:** Displaying fake alerts ("Your PDF viewer is out of date! Click here to update!") that lead to running a malicious executable.
    *   **Launching Embedded Objects:** Writing a malicious file to disk and then using the JS to execute it (e.g., `util.printf` with a format string vulnerability, or `this.submitForm` to exfiltrate data).
    *   **Reconnaissance:** Checking the version of the PDF reader to target a specific exploit.
3.  **Embedded Objects:** The PDF can have other files embedded inside it, like EXE files, Flash objects (SWF), or even other PDFs. The JavaScript or social engineering elements then convince the user to open them.

---

### The PDF Malware Analysis Toolkit

Your analysis will follow the same phased approach: **Static -> Dynamic -> Advanced.**

#### **Phase 1: Initial Triage & Static Analysis**

**Goal:** Examine the PDF structure without opening it to find suspicious elements.

1.  **pdfid & pdf-parser (Didier Stevens' Tools):** **The absolute essentials.**
    *   **`pdfid.py`**: Scans the PDF and counts key keywords. A high count of `/JavaScript`, `/OpenAction`, `/AA`, `/Launch`, or `/EmbeddedFile` is a huge red flag.
        *   `python pdfid.py malicious.pdf`
    *   **`pdf-parser.py`**: The Swiss Army knife. It parses the PDF structure to find and extract objects (like streams of JavaScript, embedded files).
        *   `python pdf-parser.py -a malicious.pdf` (Show all objects)
        *   `python pdf-parser.py -o 12 --raw -d script.js malicious.pdf` (Extract object 12 as raw data to `script.js`)
    *   **Installation:** Download from Didier Stevens' GitHub.

2.  **peepdf:** An interactive Python tool specifically designed for PDF analysis. It's fantastic for exploring the structure, analyzing JavaScript, and detecting obfuscation techniques.
    *   `peepdf -i malicious.pdf` (Enters interactive mode)
    *   Use commands like `info`, `js_code`, `streams`, `vars` to explore.

3.  **Strings & Hex Editor (HxD):** Just like with Office docs, always run `strings` on the PDF to find URLs, IP addresses, and suspicious function calls. Look for `eval`, `unescape`, `charCodeAt` (common in JS obfuscation).

#### **Phase 2: Dynamic Analysis (Behavioral)**

**Goal:** Open the PDF in a monitored environment to see what it *does*.

1.  **NoScript (Firefox Extension):** A simple but effective first test. Configure Firefox to block all JavaScript and open the PDF in the browser. If it does nothing, re-enable JS and try again. If it only acts with JS enabled, you know the JS is key.

2.  **Sandboxes:**
    *   **ANY.RUN / Hybrid Analysis / Cape Sandbox:** Upload the PDF. They will show you the network calls, dropped files, and processes spawned. This is often the fastest way to get IOCs.

3.  **VM with Monitoring Tools (The Deep Dive):**
    *   **Process Monitor (ProcMon):** The king. Filter for your PDF reader process (e.g., `AcroRd32.exe`). Watch for:
        *   File writes (especially in `%TEMP%`).
        *   Process creation (the reader spawning `cmd.exe` or `powershell.exe`).
        *   Registry changes.
    *   **Process Explorer:** To see the process tree.
    *   **Wireshark:** To capture any network callbacks.

4.  **Specialized PDF Reader:**
    *   **`jsunpack-n`** (or similar): A modified PDF reader that monitors and logs all JavaScript execution, even as it deobfuscates. This is extremely powerful.

#### **Phase 3: JavaScript Deobfuscation**

PDF JS is almost always heavily obfuscated. Your goal is to make it readable.

1.  **Manual Analysis with `pdf-parser`/`peepdf`:**
    *   Extract the JavaScript stream(s).
    *   Look for massive arrays of numbers (`[102, 111, 111]`) that are being joined or decoded.
    *   Look for `eval()`, `replace()`, `fromCharCode()`, and `unescape()` functions.

2.  **Browser Console (Chrome/Firefox DevTools):**
    *   Paste the obfuscated code into the console.
    *   Replace the final `eval()` with `console.log()`. This will often print the deobfuscated code instead of executing it.
    *   This is the quickest and most effective method for many cases.

3.  **Online Tools:**
    *   **JSBeautifier.org:** Formats messy JS to be more readable.
    *   **UnPHP:** A JS deobfuscator.

---

### Important Tips for PDF Analysis

*   **Start with `pdfid` and `pdf-parser`.** They will immediately tell you if the PDF is worth a deeper look.
*   **The `/OpenAction` and `/AA` directives are triggers.** They tell the reader to perform an action (like run JS) as soon as the document is opened.
*   **Focus on the JavaScript.** 99% of modern malicious PDFs use it. Your main goal is to extract and decode it.
*   **Exploits are harder.** If there's no JS but the file is malicious, it's likely a binary exploit. This requires memory analysis and debugging, which is advanced.
*   **Check the version of your analysis tools.** PDF specs change. Ensure your tools can handle the PDF version you're analyzing.
*   **Patch your analysis Reader.** If you're looking for a specific exploit, you need a vulnerable version of Acrobat Reader. For general JS analysis, a modern, patched reader is fine as you're just monitoring its behavior.

**Summary Workflow:**
1.  `pdfid.py` -> See high `/JavaScript` count? -> Red flag.
2.  `pdf-parser.py` -> Locate the JS object and extract it.
3.  Deobfuscate the JS manually or in a browser console.
4.  Find the final payload: a URL, a shell command, or a base64-encoded binary.
5.  Detonate in a sandboxed VM with ProcMon/Wireshark to confirm the behavior and capture the next-stage payload.


MORE :

1- open pdf file with PDFStreamDumper, we will see how many objects contains within this pdf file.
2- We can also read the MetaData of the file by using **PDFMETADATA**
3- let’s utilize PeePDF to perform thorough analysis of the PDF file.
4- we can use **PDFID**. Which checks and provides us with all the sections of the PDF file.
5- The important things to note from the output are:
1. **/Encrypt** → Total numbers of objects/sections encrypted.
2. **/JS** → Total number of section containing the JS code.
3. **/JavaScript** → Total number of section containing the JS code.
4. **/OpenAction** → Points to the code which will be run when the PDF will be opened.
5. **/AA** → This points to the defined additional triggers.


we  use [https://playcode.io/empty_javascript](https://playcode.io/empty_javascript) to run the JS code 