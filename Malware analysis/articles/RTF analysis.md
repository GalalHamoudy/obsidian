**The Core Concept: RTF files are exploit containers.**

Unlike PDFs (which use JS) or Word docs (which use VBA), RTFs themselves don't contain "executable code" in the same way. Instead, their primary method of infection is by **exploiting vulnerabilities in the software that opens them** (like Microsoft Word).

---

### How Malicious RTFs Work

An RTF file is a structured document format that can contain embedded objects. The attack flow is typically:

1.  **Embedded Exploit Code:** The RTF contains a specially crafted, malicious embedded object designed to trigger a memory corruption vulnerability (e.g., buffer overflow, use-after-free) in the Word RTF parser.
2.  **The Exploit Triggers:** When the vulnerable version of Word opens the file, the exploit code is processed, and the vulnerability is triggered.
3.  **Control is Gained:** This vulnerability allows the attacker to hijack the execution flow of the program, redirecting it to their own code.
4.  **Shellcode Executes:** The exploit passes control to a small piece of code called **shellcode** that is also embedded within the RTF. This shellcode is the real payload.
5.  **Payload Deployment:** The shellcode's job is to download and execute a final payload from the internet, or to decode and execute a payload that is also embedded within the file.

The most common embedded objects used for exploits are **OLE (Object Linking and Embedding)** objects, and among those, the **"Equation Editor" (EQNEDT32.EXE)** was notoriously exploited for years due to its many vulnerabilities.

---

### The RTF Malware Analysis Toolkit

Your analysis focuses on identifying the embedded exploit object and the final shellcode/payload.

#### **Phase 1: Initial Triage & Static Analysis**

**Goal:** Unpack the RTF structure and find the malicious embedded object.

1.  **rtfobj (from oletools):** **This is your most important tool.** It parses the RTF file and extracts all embedded objects (OLE, Packages, etc.), which are almost always the malicious component.
    *   `rtfobj.py malicious.rtf` (Lists all objects)
    *   `rtfobj.py -s all -d ole_object.bin malicious.rtf` (Extracts all objects to files)
    *   **What to look for:** An object with a suspicious CLSID (Class ID) or Datalib name. For example, the Equation Editor CLSID (`{0002CE02-0000-0000-C000-000000000046}`) is a massive red flag.

2.  **Strings & Hex Editor (HxD):** Run `strings` on the RTF file. Look for:
    *   **OLE object headers:** `objclass`, `objdata`, `{\object`
    *   **Exploit patterns:** Long strings of 'A's (`AAAA...`) can indicate a buffer overflow attempt.
    *   **Shellcode patterns:** `\x90\x90\x90` (NOP sleds), `\xE8\xFF` (common opcodes), URLs, IPs.
    *   **Version checks:** Strings like `Word\.Document\.8` indicate the exploit targets a specific Word version.

3.  **rtfdump.py:** Another useful tool for scanning RTF files for suspicious keywords and embedded data.

#### **Phase 2: Analyzing the Extracted Object**

The object extracted by `rtfobj` is now your new primary sample. It is often an OLE file or a CAB archive.

1.  **oleid & olevba (oletools):** Analyze the extracted object. It might be a compound file binary (CFB) that itself contains streams and VBA macros (though less common).
    *   `oleid.py ole_object.bin`
    *   `olevba.py ole_object.bin`

2.  **File Command:** Identify what you've extracted.
    *   `file ole_object.bin`

3.  **7-Zip / CAB Extractor:** If the object is a CABinet file (`.cab`), extract it. It may contain the next-stage payload or DLLs.

4.  **Shellcode Analysis:** If you find a blob of data that looks like shellcode (e.g., after extracting from an OLE stream), you need to analyze it.
    *   **scdbg:** A shellcode analysis tool that emulates execution and shows API calls (file, network, etc.) without running the code for real.
    *   **BlobRunner:** A simple tool to allocate memory, load your shellcode blob, and execute it while being attached to a debugger.
    *   **Debugger (x64dbg):** For advanced analysis, load the shellcode into a debugger to step through its instructions.

#### **Phase 3: Dynamic Analysis (Behavioral)**

**Goal:** Execute the RTF in a monitored, vulnerable environment to capture the full chain.

1.  **The Lab Setup is CRITICAL:**
    *   You **must** use a vulnerable version of Microsoft Word that the exploit targets (e.g., Word 2010 on Windows 7).
    *   A modern, patched Word will not trigger the exploit, and your analysis will fail.
    *   snapshot your VM before detonation.

2.  **Process Monitor (ProcMon):** Filter for `WINWORD.EXE`. Watch for:
    *   It spawning a child process (e.g., `cmd.exe`, `powershell.exe`). This is the ultimate sign of success.
    *   It writing a file to `%TEMP%` and then executing it.
    *   It accessing specific registry keys related to exploit mitigations.

3.  **Debugger (x64dbg):** Attach x64dbg to `WINWORD.EXE` *before* opening the RTF file. When the exploit triggers, the debugger will catch the exception or the hijacked execution flow. This is advanced but the best way to see the exploit in action.

4.  **Wireshark:** Capture any network callbacks made by the shellcode to download the final payload.

### Important Tips for RTF Analysis

*   **Start with `rtfobj`.** It will immediately tell you if there are embedded objects and allow you to extract them. This is 90% of the battle.
*   **Know your exploits.** Familiarize yourself with common exploited vulnerabilities (CVE numbers) and their associated CLSIDs or patterns. (e.g., CVE-2017-11882 in Equation Editor).
*   **The RTF itself is just a wrapper.** The real malicious content is *inside* the embedded object. Your analysis must focus on that extracted object.
*   **Use a vulnerable environment.** Dynamic analysis without the correct, unpatched version of Word is often pointless.
*   **Shellcode is the key.** The goal of the exploit is to run the shellcode. Your goal is to find and analyze that shellcode to understand the final payload (e.g., a URL to download a Trojan).

**Summary Workflow:**
1.  **`rtfobj.py malicious.rtf`** -> Extract the suspicious embedded object(s).
2.  Analyze the extracted object with `file`, `oleid`, `strings`, and `7-Zip`.
3.  If it's shellcode, analyze it with **scdbg** or a debugger.
4.  If it's another file (PE, DLL), analyze that file separately.
5.  **Detonate** the original RTF in a **vulnerable Word VM** with **ProcMon** and **Wireshark** running to observe the full attack chain and capture the final payload.